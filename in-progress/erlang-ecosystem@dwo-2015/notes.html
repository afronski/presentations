    <div>
        <section class="important __for_review">
          <h1>Historia</h1>
          <h1>Erlang VM === BEAM</li>
          <em>TODO: interactive timeline</em>
          <a href="https://github.com/marmelab/EventDrops">Event Drops</a>
          <h2>30 years</h2>
        </section>

        <section class="important __for_review">
          <h2>Real problems, 30 years ago</h2>
          <ul>
            <li>Distribution</li>
            <li>Concurrency</li>
            <li>Redundant hardware - more hardware, lesser probability of failure</li>
            <li>Fault tolerance</li>
            <li>Small RAM, slow CPU - lightweight processes</li>
          </ul>
          <h2>TODO: Image with calls to switch (1986), requests to server (2015) - similarities in behaviour and requirements</h2>
          <h2>Still actual</h2>
          <h2>Soft real-time systems</h2>
          <h2>Other use cases</h2>

        </section>

        <section class="important __for_review">
          <h2>Visualizations</h2>
          <ul>
            <li>Wybór języka - drogowskazy i rozstaj dróg</li>
            <li>mo.js - motion animation library</li>
            <li>d3.js tree - supervision tree</li>
            <li>d3.js puzzle - key concepts of Erlang VM related with scalabilty and reliability</li>
            <li>d3.js timeline - Erlang ecosystem history</li>
            <li>d3.js choices - different Erlang VM languages</li>
            <li>d3.js influence - error kernel and type of errors</li>
          </ul>
        </section>

        <section class="important __for_review">
          <blockquote>The systems we were building are world wide distributed systems. Where’s the shared memory when you’ve got one node in London and another in Paris and another in Stockholm. There is no shared memory!
Joe Armstrong</blockquote>
        </section>

        <section class="important __for_review">
          <ul>
            <li>Share nothing</li>
            <li>Isolation</li>
            <li>Lightweight processes</li>
            <li>Let it crash === different approach to error handling</li>
            <li>No defensive programming, think about erroneous situations upfront.</li>
            <li>Build system that deals with errors, and not catches them.</li>
            <li>After dealing with error kernel, and building supervision you can ignore rest of errors.</li>
            <li>MODERN OS DESIGN -> ISOLATION, SMALL DOMAINS, ONE THING DOES NOT AFFECT WHOLE SYSTEM</li>
            <li>Resilience !== Reliability</li>
            <li>Build systems, not monolihts.</li>
            <li>Microservices with 30 years legacy (legacy in this case is a pride not pain)!</li>
            <li>Independence and isolation eases other stuff (e.g. GC).</li>
            <li>Built-in distribution and opaque implementation to all system.</li>
            <li>Sending message across cluster is not different than sending it to the process on the same VM.</li>
          </ul>
        </section>

        <section class="important __for_review">
          <h1>OTP</h1>

          <ul>
            <li>Small community (around 7k active paid programmers).</li>
            <li>Niche, expertise level required.</li>
            <li>It was harder to grasp by beginner (docs, knowledge, tooling) but it rapidly changes</li>
          </ul>
        </section>

        <section class="important __for_review">
          <ul>
            <li>Behaviours, Supervisors, Applications, gen_server</li>
            <li>Darn cheap processes</li>
            <li>Observability - Links (HW inspired), Monitors</li>
            <li>INTROSPECTION - higher level of debugging, maintenance, remember 20 years not 1 year.</li>
            <li>60% of time from a software lifecycle is spent in MAINTENANCE</li>
            <li>Write for maintainability, optimize tools which are opaque for your design (e.g. VM - it is a real Knuth quote origin)</li>
            <li>Supervisors - transient errors are most common (research, Joe Armstrong PhD thesis)</li>
            <li>Standard library</li>
            <li>Applications like components, again - <em>building systems</em></li>
            <li><img src="img/processes.png" alt="Message passing." /></li>
            <li>Show supervision trees - animation (d3.js) <a href="https://gist.github.com/d3noob/8326869">d3 vertical tree</a></li>
            <li>Show <em>erlubi</em> visualization (gif, how it looks like)</li>
          </ul>
        </section>

        <section class="important __for_review">
          <ul>
            <li>Erlang !== (Erlang VM === BEAM)</li>
            <li>Elixir</li>
            <li>LFE (Lisp Flavoured Erlang)</li>
            <li>Erlog, Luaerl, Joxa ...</li>
            <li>Syntax is not a real problem, huge mindset shift is a problem</li>
            <li>Concepts are harder to explain and grasp, especially for people that did not work with highly concurrent applications before</li>
            <li>IMPORTANT: Good platform only eases certain stuff, but still it requires significant knowledge and skills</li>
            <li>AXD301 was written in Erlang, but also in C - whole system was designed reliable and resilient since beginning so it required at first significant knowledge and skills.</li>
          </ul>
        </section>
    </div>
