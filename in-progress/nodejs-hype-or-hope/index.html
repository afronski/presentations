<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8">
    <title>Node.js - Hype or Hope? ;)</title>

    <meta name="description" content="Presentation, introduction to core concepts of Node.js, with pros, cons, use cases." />
    <meta name="author" content="Wojciech Gawroński" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/TangleKit.css" />
    <link rel="stylesheet" href="css/theme/default.css" id="theme" />

    <link rel="stylesheet" href="lib/css/github.css" />

    <script src="js/raphael.js"></script>
    <script src="js/raphael.tachometer.min.js"></script>
    <script src="js/analytics.js"></script>
    <script src="js/popup.js"></script>
    <script src="js/Tangle.js"></script>
    <script src="js/mootools.js"></script>
    <script src="js/sprintf.js"></script>
    <script src="js/BVTouchable.js"></script>
    <script src="js/TangleKit.js"></script>
    <script>
      var RAD = Math.PI / 180;

      function createRectPath(x, y, a) {
        return "M" + x + "," + y + "l" + a + ",0 0," + a + "-" + a + ",0z";
      }

      function createTrianglePath(x, y, a) {
        return "M" + x + "," + y + "l" + a / 2 + "," + a + " -" + a + ",0z";
      }

      function createRightArrowPath(x, y) {
        return "M" + x + "," + y + "m-10-10l40,0 0-6 20,16 -20,16 0-6 -40,0 -0-16z"
      }

      function createArcPath(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.cos(-startAngle * RAD),
            x2 = cx + r * Math.cos(-endAngle * RAD),
            y1 = cy + r * Math.sin(-startAngle * RAD),
            y2 = cy + r * Math.sin(-endAngle * RAD);

        return ["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"];
      }

      Raphael.fn.arrow = function (x, y) {
          return this.path(["M", x, y ] + "m-10-10l20,0 0-6 10,16 -10,16 0-6 -20,0 0,6 -10-16 10-16z")
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.2 });
      };

      Raphael.fn.rightArrow = function (x, y) {
          return this.path(createRightArrowPath(x, y))
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.5 });
      };

      Raphael.fn.thinArrow = function(x1, y1, x2, y2, size) {
        var angle = Raphael.angle(x1, y1, x2, y2);
            a45   = Raphael.rad(angle - 45),
            a45m  = Raphael.rad(angle + 45),
            a135  = Raphael.rad(angle - 135),
            a135m = Raphael.rad(angle + 135),
            x1a = x1 + Math.cos(a135) * size,
            y1a = y1 + Math.sin(a135) * size,
            x1b = x1 + Math.cos(a135m) * size,
            y1b = y1 + Math.sin(a135m) * size,
            x2a = x2 + Math.cos(a45) * size,
            y2a = y2 + Math.sin(a45) * size,
            x2b = x2 + Math.cos(a45m) * size,
            y2b = y2 + Math.sin(a45m) * size;

        return this.path("M" + x1 + " " + y1 + "L" + x1a + " " + y1a + "M" + x1 + " " + y1 + "L" + x1b + " " + y1b +
                         "M" + x1 + " " + y1 + "L" + x2 +  " " + y2 +
                         "M" + x2 + " " + y2 + "L" + x2a + " " + y2a + "M" + x2 + " " + y2 + "L" + x2b + " " + y2b);
      };

      var dashed = { fill: "none", stroke: "#666", "stroke-dasharray": "- " },
          black = "#333",
          gray = "#888",
          white = "#ffffff",
          red = "#ff0000",
          green = "#00ff00",
          yellow = "#ffff00",
          lightBlue = "#00ffff";
    </script>
    <script>
      document.write('<link rel="stylesheet" href="css/print/' +
                     (window.location.search.match(/print-pdf/gi) ? "pdf" : "paper") +
                    '.css" type="text/css" media="print">');
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Node.js</h1>
          <h2>Hype or hope?</h2>
          <span class="license">
            Licencja: <a href="http://creativecommons.org/licenses/by-nd/3.0/pl/">CC BY-ND 3.0 PL</a>
          </span>
          <aside class="notes">
            <ul>
              <li>Witam Was na prezentacji poświęconej Node.js.</li>
              <li>Technologia ta swego czasu narobiła niemałego zamieszania.</li>
              <li>To będzie dość intensywne 25 minut.</li>
              <li>Całość obejmuje wprowadzenie, wady, zalety i przypadki użycia.</li>
              <li>Slajdy będą dostępne do ściągnięcia wraz z bibliografią i notatkami.</li>
            </ul>
          </aside>
        </section>

        <section>

          <section>
            <h1>Hello Node!</h1>
            <div class="spaced">
              <pre><code data-trim class="javascript">
require("http").createServer(function(request, response) {

  response.writeHead(200, { "Content-Type": "text/plain" });
  response.end("Hello World\n");

}).listen(1337, "127.0.0.1");

console.log("Server running at http://127.0.0.1:1337/");
              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Przykład + refleksja, która pokaże dlaczego jest tyle niezdrowego zamieszania.</li>
                <li>Nauka nowych rzeczy przebiega metodą ogół-szczegół.</li>
                <li>Małe nachylenie krzywej uczenia ułatwia naukę i skłania do eksperymentów.</li>
                <li>Dopiero gdy receptury zaczną Nas ograniczać zaczynamy sięgać głębiej po kolejne szczegóły i detale.</li>
                <li>Taki model nauki jest zgodny z modelem nabywania kompetencji braci Dreyfus.</li>
                <li>W ten sam sposób pracowaliśmy w szkole czy na studiach.</li>
                <li>Autor tej platformy, nawet się nie spodziewał jakie zamieszanie spowoduje prezentując powyższy kod.</li>
                <li>Stworzyliśmy serwer HTTP w kilku linijkach kodu.</li>
                <li>Przy takim sposobie nauki, nakierowanym na efekt umykają szczegóły.</li>
                <li>Jako ludzie, mamy tendencję do "selektywnego słuchania" i tzw. "cognitive biases"</li>
                <li>Aby wykorzystać pełen potencjał ukryty pod tymi kilkoma linijkami kodu, należy sięgnąć dużo głębiej.</li>
                <li>Właśnie dlatego zacznijmy od analizy jak działa powyższy kod.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Analiza</h2>
            <div>
              <p>Tworzymy serwer HTTP i nasłuchujemy</p>
              <pre><code data-trim class="javascript">
require("http")
  .createServer(handleRequest)
  .listen(1337, "127.0.0.1");

console.log("Server running at http://127.0.0.1:1337/");
              </code></pre>
            </div>

            <div class="fragment">
              <p>Po nadejściu żądania wywołana zostanie funkcja <code>handleRequest</code></p>
              <pre><code data-trim class="javascript">
function handleRequest(request, response) {
  response.writeHead(200, { "Content-Type": "text/plain" });
  response.end("Hello World\n");
}
              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>UPROSZCZENIE: Kod wykonywany jest dwuetapowo.</li>
                <li>Wyodrębniamy i pominiemy funkcję służącą do obsługi żądania.</li>
                <li>Tworzymy serwer, podpinamy naszą implementację funkcji obsługi żądania i nasłuchujemy na porcie.</li>
                <li>Gdy klient wyśle żądanie zostanie wykonana druga część kodu, wcześniej podpięta, obsługująca żądanie.</li>
                <li>Zasada działania platformy - asynchroniczna obsługa wszelkich operacji.</li>
                <li>Nie czekamy i nie blokujemy wykonania - to Nas informują, że zaszło interesujące Nas zdarzenie.</li>
                <li>Złota zasada Hollywood ("Nie dzwoń do nas. My oddzwonimy do ciebie").<li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section>
            <h2>Czym jest Node.js?</h2>
            <p class="quoted"><strong><em>Node.js</em></strong> is a platform built on <strong>Chrome's JavaScript runtime</strong> for easily building fast, scalable network applications. Node.js uses an <strong>event-driven</strong>, <strong>non-blocking I/O model</strong> that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p>
            <aside class="notes">
              <ul>
                <li>Definicja z głównej strony.</li>
                <li>Dużo tekstu, mało treści.</li>
                <li>Pierwsze zdanie - Node.js to nie framework - to platforma (często mówi się również środowisko).</li>
                <li>Dalej mamy już tylko marketing i puste frazesy.</li>
                <li>Co gorsza ukrywa ona jeden ważny szczegół.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Marketingowy Bełkot</h2>
            <h3>Rozszyfrujmy to!</h3>
            <aside class="notes">
              <ul>
                <li>Spróbujmy to rozszyfrować!</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>V8</h2>
            <h3>Chrome's JavaScript runtime</h3>
            <aside class="notes">
              <ul>
                <li>Kluczowy element, fundament całego rozwiązania.</li>
                <li>Popularny. Interpreter języka JavaScript wykorzystywany w przeglądarce Google Chrome / Chromium.</li>
                <li>Otwarty. Źródła na liberalnej licencji.</li>
                <li>Szybki. Bardzo mocny kompilator optymalizujący (Crankshaft, V8 -> Mechanika Samochodowa).</li>
                <li>Duża ironia - nazwać wałem korbowym, główny kompilator optymalizujący.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Event-Driven Model</h2>
            <button id="sendEvents">Trigger events</button>
            <div id="edd"></div>
            <aside class="notes">
              <ul>
                <li>Koncepcja programowania oparta o zdarzenia nie jest niczym nowym.</li>
                <li>Główny nurt programowania w JavaScript w przeglądarce.</li>
                <li>Wszystkie operacje związane z przeglądarką są obsługiwane za pomocą obsługi zdarzeń.</li>
                <li>TODO: OPIS</li>
              </ul>
            </aside>
            <script>
              (function() {
                var paper = Raphael("edd", 400, 400),
                    opacity = 0.5,
                    set,
                    events,
                    fade = function (id) {
                      return function () {
                        set[id].attr({ fill: white, r: 12 }).animate({ fill: gray, r: 8 }, 500);
                      };
                    },
                    duration = 1000,
                    i;

                function reset() {
                  set = paper.set(paper.circle(300, 200, 8).attr({ fill: green, opacity: opacity }),
                                  paper.circle(200, 100, 8).attr({ fill: green, opacity: opacity }),
                                  paper.circle(100, 200, 8).attr({ fill: green, opacity: opacity }),
                                  paper.circle(200, 300, 8).attr({ fill: green, opacity: opacity }),
                                  paper.circle(200, 200, 12).attr({ fill: red, opacity: opacity }));
                }

                paper.text(200, 120, "Nadawca")
                     .attr({ font: "14px 'Helvetica Neue', Arial", "font-weight": "bold", fill: red });

                paper.text(200, 40, "Odbiorcy")
                     .attr({ font: "14px 'Helvetica Neue', Arial", "font-weight": "bold", fill: green });

                reset();

                document.querySelector("#sendEvents").addEventListener("click", function() {
                  reset();

                  events = paper.set(paper.circle(200, 200, 10).attr({ stroke: white, "stroke-width": 4 }),
                                     paper.circle(200, 200, 10).attr({ stroke: white, "stroke-width": 4 }),
                                     paper.circle(200, 200, 10).attr({ stroke: white, "stroke-width": 4 }),
                                     paper.circle(200, 200, 10).attr({ stroke: white, "stroke-width": 4 }));

                  events[0].stop().animate({ cy: 100, easing: "linear", callback: fade(1) }, duration)
                                  .animate({ cx: 200, easing: "linear" }, duration);

                  events[1].stop().animate({ cy: 200, easing: "linear", callback: fade(2) }, duration)
                                  .animate({ cx: 100, easing: "linear" }, duration);

                  events[2].stop().animate({ cy: 300, easing: "linear", callback: fade(3) }, duration)
                                  .animate({ cx: 200, easing: "linear" }, duration);

                  events[3].stop().animate({ cy: 200, easing: "linear", callback: fade(0) }, duration)
                                  .animate({ cx: 300, easing: "linear" }, duration);
                });
              } ());
            </script>
          </section>

          <section>
            <h2>Non-blocking I/O</h2>
            <h3>TODO: Animacja (Tangle)</h3>
            <aside class="notes">
              <ul>
                <li>Idea nieblokującego, asynchronicznego sposobu obsługi zdarzeń wejścia-wyjścia to kluczowy element.</li>
                <li>Podstawa efektywniejszego wykorzystania zasobów.</li>
                <li>TODO: OPIS</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Event Loop</h2>
            <h3>TODO: Animacja (Tangle)</h3>
            <aside class="notes">
              <ul>
                <li>Tego elementu nigdzie nie ma w przytoczonej definicji.</li>
                <li>Jest on tzw. "wiedzą ukrytą" i główną przyczyną nieporozumień dotyczących Node.js.</li>
                <li>Połączenie wpływa na model programowania i skalowalność zaimplementowanego rozwiązania.</li>
                <li>TODO: OPIS</li>
                <li>Nie jest również innowacyjnym elementem (szczegóły za chwilę).</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section>
            <h2>No i gdzie ta innowacja?</h2>
            <ul>
              <li>
                JavaScript na serwerze nie jest nową koncepcją.
              </li>
              <li class="fragment">
                Asynchroniczna obsługa żądań również nie jest niczym nowym.
              </li>
              <li class="fragment">
                Innowacyjne jest dopiero <strong>połączenie obu elementów</strong>.
              </li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Żaden z wymienionych elementów nie jest innowacyjny.</li>
                <li>JavaScript na serwerze to nie jest nowa koncepcja - Java - Rhino, RingoJS, Helma.</li>
                <li>Pierwszy SSJS - LiveScript, 1994 rok, Netscape Enterprise Server.</li>
                <li>Asynchroniczna obsługa żądań to również nie jest nowe rozwiązanie.</li>
                <li>Połączenie jest innowacyjne - SSJS oraz "non-blocking I/O".</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Dlaczego więc JavaScript?</h2>
            <h3 class="fragment">Z trzech głównych powodów:</h3>
            <ul>
              <li class="fragment">
                Asynchroniczna obsługa zdarzeń to standardowe podejście stosowane w JavaScript.
                <pre>
                  <code class="javascript" data-trim>
document.addEventListener("DOMContentLoaded", eventHandler);
                  </code>
                </pre>
              </li>
              <li class="fragment">
                Brak zależności w postaci bibliotek obsługujących operacje wejścia-wyjścia.
              </li>
              <li class="fragment">V8</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Model zdarzeniowy.</li>
                <li>Budowa wewnętrzna przeglądarek.</li>
                <li>UPROSZCZENIE: Skrypt jest wykonywany w jednym wątku, UI i wejście w drugim.</li>
                <li>Asynchroniczna obsługa zdarzeń to sposób rozwiązania problemu przełączania kontekstu.</li>
                <li>Ryan eksperymentował z kilkoma językami, żaden nie okazał się na tyle elastyczny.</li>
                <li>Aby dostosować istniejący język należałoby stworzyć kolejną implementację biblioteki standardowej.</li>
                <li>Efekt: Niekompatybilność, zamieszanie.</li>
                <li>Dodatkowe konstrukcje językowe byłyby mile widziane.</li>
                <li>ECMAScript nie posiada żadnej ustandaryzowanej biblioteki do I/O.</li>
                <li>Sam standard nie wymaga ani nie opisuje sposobu obsługi wejścia - wyjścia.</li>
                <li>Jest to otwarta droga do nowej implementacji.</li>
                <li>Jak wcześniej wspomniałem, jednym z najważniejszych powodów był właśnie silnik V8.</li>
                <li>Ryan nie musiał martwić się o implementację interpretera, kompilatora JIT.</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section>
            <h1>Historia</h1>
            <h2>Kartka z kalendarza</h2>
            <aside class="notes">
              <ul>
                <li>Cofnijmy się w czasie i spójrzmy w jaki sposób rozwijał się Node.js.</li>
              </ul>
            </aside>
          </section>

          <section>
            <ol class="no-bullets">
              <li>
                <em>2009</em>
                <span>Ryan Dahl prezentuje koncepcję Node.js</span>
              </li>
              <li class="fragment">
                <em>2009 - 2011</em>
                <span>Ciągły rozwój, powstają wersje 0.2 oraz 0.4</span>
              </li>
              <li class="fragment">
                <em>Wrzesień 2011</em>
                <span>Powstaje <pre class="pre-inline">libuv</pre></span>
              </li>
              <li class="fragment">
                <em>Listopad 2011</em>
                <span>Powstaje wersja 0.6 - "pierwsza stabilna" gałąź</span>
              </li>
              <li class="fragment">
                <em>Grudzień 2011</em>
                <span>Wsparcie firmy Microsoft dla Node.js na Windows Azure</span>
              </li>
              <li class="fragment">
                <em>Styczeń 2012</em>
                <span>Ryan opuszcza Node.js, opiekunem zostaje Isaac</span>
              </li>
              <li class="fragment">
                <em>Czerwiec 2012</em>
                <span>Pojawia najpopularniejsza obecnie wersja 0.8</span>
              </li>
              <li class="fragment">
                <em>Grudzień 2012</em>
                <span>Pojawia się nowe API dla strumieni w wersji 0.10.x</span>
              </li>
              <li class="fragment">
                <em>Maj 2013</em>
                <span>Wersja 0.12 będzie ostatnią przed wydaniem 1.0</span>
              </li>
            </ol>
            <aside class="notes">
              <ul>
                <li>Cykl wydawniczy jest szybki - numery parzyste = stabilne wersje, nieparzyste = rozwojowe gałęzie.</li>
                <li>Powstanie libuv związane jest konsekwencją wymagania obsługi wielu platform.</li>
                <li>W uproszczeniu można powiedzieć, że libuv jest warstwą pośrednią między systemem operacyjnym a V8.</li>
                <li>Wprowadza ona nieblokujące operacje wejścia-wyjścia.</li>
                <li>Wsparcia ze strony Microsoftu to ważny element z poważnymi konsekwencjami.</li>
                <li>Wiele firm związanych typowo z Enterprise, zaczyna dostrzegać Node.</li>
                <li>Dodatkowo dzięki oddelegowaniu programistów wsparcie dla systemu Windows ulega znacznej poprawie.</li>
                <li>Microsoft pomaga zarówno przy rdzeniu Node.js jak i przy libuv.</li>
                <li>Nie znane są dokładne powody odejścia Ryana.</li>
                <li>Plotki mówiły o nowym projekcie, w który Ryan zaangażował się na 100%.</li>
                <li>Najważniejsze, że odejście nie spowodowało przestoju ani załamania się pracy nad projektem.</li>
                <li>Wersja 1.0 zaplanowana jest na pierwszy kwartał 2014.</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section>
            <h1>Motywacja</h1>
            <h2>Jak efektywniej wykorzystać istniejącą infrastrukturę?</h2>
            <aside class="notes">
              <ul>
                <li>Ryan tworzył sporo rozwiązań w PHP i Ruby (we frameworku którego nazwy nie wolno wymawiać).</li>
                <li>Frustracja: jedynym sposobem aby obsłużyć duży ruch było kupienie większego lub nowego serwera.</li>
                <li>Rozmiar frameworka jest bardzo widoczną wadą jeśli chodzi o skalowanie.</li>
                <li>Fascynacja modelem działania nginx i EventMachine.</li>
                <li>Nadal jednak widział pole do usprawnień i postanowił stworzyć własne dedykowane rozwiązanie.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Joyent</h2>
            <ul class="no-bullets">
              <li>Jeśli nie wiadomo o co chodzi, to chodzi o pieniądze...</li>
              <li class="fragment">... a zwłaszcza o to jak ich zbyt dużo nie wydać ;)</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Po pierwszej prezentacji Node.js na forum PHPowego meetupu do Ryana zgłasza się Joyent.</li>
                <li>Start-up z doliny krzemowej, tworzący własną platformę cloud computing.</li>
                <li>Są zorientowani na skalowalność i najefektywniejsze wykorzystanie infrastruktury.</li>
                <li>Joyent zatrudnia Ryana, formuje się zespół rozwijający Node.js.</li>
                <li>W tym samym czasie Joyent proponuje pierwszy dedykowany hosting dla Node.js na systemie SmartOS.</li>
                <li>System operacyjny, który wyewoluował z Solarisa.</li>
                <li>Zorientowany na skalowalność, cloud computing i wirtualizację tj. KVM lub Solaris Secure Zones.</li>
                <li>System posiada olbrzymie możliwości instrumentacji dzięki DTrace.</li>
                <li>CIEKAWOSTKĄ: dtrace jest niemożliwy do przeniesienia na platformę UNIX/Linux (Oracle i patenty).</li>
                <li>Zainteresowanych szczegółami zapraszam do bibliografii.</li>
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2 class="no-uppercase">C10k problem</h2>
            <p><em>concurrent ten thousand connections problem</em></p>
            <p>
              Problem optymalizacji zasobów w celu osiągnięcia jak największej liczby żądań obsłużonych równolegle.
            </p>
            <aside class="notes">
              <ul>
                <li>Optymalizacja wykorzystania zasobów w celu obsłużenia jak największej liczby żądań równolegle.</li>
                <li>Ten problem jest znany właśnie pod nazwą c10k i został zdefiniowany przez Dana Kegela.</li>
                <li>Joyent zmaga się z tym problemem, chce jak najlepiej wykorzystać stworzoną chmurę.</li>
                <li>Potrzebuje dedykowanego rozwiązania.</li>
                <li>Pętla zdarzeń i asynchroniczność, ułatwia efektywniejsze wykorzystanie istniejącej infrastruktury.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Inne rozwiązania problemu C10k</h2>
            <ul>
              <li class="fragment">nginx</li>
              <li class="fragment">lighttpd</li>
              <li class="fragment">Sinatra</li>
              <li class="fragment">EventMachine</li>
              <li class="fragment">Twisted</li>
              <li class="fragment">Netty</li>
              <li class="fragment">IIS + WebSync</li>
              <li class="fragment">Yaws</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Node.JS nie jest pierwszą odpowiedzią jeśli chodzi o próbę rozwiązania "C10k problem".</li>
                <li>Najbardziej dojrzałym rozwiązaniem jest oczywiście nginx.</li>
                <li>Praktycznie każdy język lub platforma związana z programowaniem webowym posiada własną alternatywę.</li>
                <li>CIEKAWOSTKA: pierwszy moduł obsługi http zaimplementowany w Node.js opierał się o nginx.</li>
                <li>CIEKAWOSTKA: prawie 1.5k linii switcha z masą heurystyk i optymalizacji.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Skalowalność</h1>
            <div id="scalability" class="justified-to-left">
              <span data-var="requests"
                    data-step="100"
                    data-min="1"
                    data-max="10000"
                    data-format="requests"
                    class="TKAdjustableNumber"></span> a zużycie pamięci serwera:
              <ul>
                <li><div>Tomcat</div> <span data-var="javaMemory" data-format="memory"></span></li>
                <li><div>IIS</div> <span data-var="netMemory" data-format="memory"></span></li>
                <li><div>Apache</div> <span data-var="apacheMemory" data-format="memory"></span></li>
                <li><div>lighttpd</div> <span data-var="lighttpdMemory" data-format="memory"></span></li>
                <li><div>nginx</div> <span data-var="nginxMemory" data-format="memory"></span></li>
                <li><div>Node.js</div> <span data-var="nodeMemory" data-format="memory"></span></li>
              </ul>
            </div>
            <aside class="notes">
              <ul>
                <li>Jednym z wymiarów skalowalności jest zużycie pamięci.</li>
                <li>Jedynie Node.js jest w stanie obsłużyć 10k żądań dla małej instancji na Amazon EC2.</li>
                <li>Tylko nginx, Node.js oraz lighttpd potrafią obsłużyć 10k dla jednej dużej instacji.</li>
                <li>Wartości obliczane na podstawie zużycia pamięci przy domyślnej konfiguracji i braku pluginów.</li>
                <li>Wartość jest sumą zużycia pamięci samego procesu oraz iloczynu zużycia pamięci żądania i ich ilości.</li>
              </ul>
            </aside>
            <script>
              function pad(value) {
                if (value < 100 && value >= 10) {
                  return "0" + value;
                } else if (value < 10 && value >= 0) {
                  return "00" + value;
                } else {
                  return value;
                }
              }

              function thousands(value) {
                if (value >= 1000) {
                  return ~~(value / 1000) + " " + pad(value % 1000);
                } else {
                  return value.toString();
                }
              }

              Tangle.formats.requests = function(value) {
                if (value === 1) {
                  return thousands(value) + " żądanie";
                } else if (value > 1 && value < 5) {
                  return thousands(value) + " równoległe żądania";
                } else {
                  return thousands(value) + " równoległych żądań";
                }
              };

              Tangle.formats.memory = function(value) {
                var memory;

                if (value < 1024) {
                  return value + " KB";
                } else if ((value / 1024) < 1024) {
                  return ~~(value / 1024) + " MB";
                } else if ((value / (1024 * 1024)) < 1024) {
                  memory = ~~(value / (1024 * 1024));

                  if (memory > 8) {
                    memory = "<span style='color: red;'>" + memory + " GB</span>";
                  } else {
                    memory = "<span style='color: yellow;'>" + memory + " GB</span>";
                  }

                  return memory;
                }
              };

              var MB = function(value) {
                    return value * 1024;
                  },
                  tangle = new Tangle(document.querySelector("#scalability"), {
                    initialize: function () { this.requests = 1; },
                    update:     function () {
                      this.javaMemory = MB(120) + this.requests * MB(18);
                      this.netMemory = MB(100) + this.requests * MB(15);
                      this.apacheMemory = MB(40) + this.requests * MB(10);
                      this.lighttpdMemory = MB(10) + this.requests * 160;
                      this.nginxMemory = MB(10) + this.requests * 128;
                      this.nodeMemory = MB(3) + this.requests * 32;
                    }
                  });
            </script>
          </section>

        </section>

        <section>

          <section>
            <h1>Pro</h1>
            <aside class="notes">
              <ul>
                <li>Chciałbym teraz pokazać wady i zalety Node.js</li>
                <li>Na pierwszy ogień przykłady w których zastosowanie omawianej technologii przynosi wymierne korzyści.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>DIRTy Applications</h2>
            <h3><acronym class="fragment">DIRT = Data Intensive Real-Time</acronym></h3>
            <aside class="notes">
              <ul>
                <li>Rozwinięciem skrótu DIRT jest Data Intensive Real-Time.</li>
                <li>Aplikacja przetwarza duże ilości danych w czasie rzeczywistym.</li>
                <li>Potrzebuje utrzymywać równolegle kilka tysięcy aktywnych połączeń.</li>
                <li>Intensywnie wykorzystuje WebSockets, Server-Side Events.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Mashup Applications</h2>
            <img src="img/ifttt.jpg" class="half-sized" alt="IFTTT Visualization" />
            <aside class="notes">
              <ul>
                <li>Mashup to webowa aplikacja hybrydowa, łącząca wiele usług w celu rozwiązania określonego problemu.</li>
                <li>Bardzo dobrym przykładem takiej aplikacji może być serwis IFTTT.</li>
                <li>
                  Inny wymyślny przykład:
                  <ul>
                    <li>Aktywność hasztagów Twittera,</li>
                    <li>Zdjęć z serwisu Instagram,</li>
                    <li>O określonej geolokalizacji, na mapie Microsoft Bing,</li>
                    <li>Z personalizacją wyszukiwania za pomocą kont Facebooka, Google (OAuth) lub Mozilla Persona.</li>
                  </ul>
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2><em>Glue</em> Layer / Middleware</h2>
            <h3>Warstwa pomiędzy usługami</h3>
            <svg id="convert" version="1.1" width="340" height="200" xmlns="http://www.w3.org/2000/svg"></svg>
            <aside class="notes">
              <ul>
                <li>Bardzo częstym przypadkiem użycia jest wykorzystanie Node.js jako serwera pośredniczącego.</li>
                <li>Popularne: małe serwery proxy, inteligentne serwery cache, konwersji jednego typu akcji na inny.</li>
              </ul>
            </aside>
            <script>
              (function () {
                var paper = Raphael("convert", 340, 200),
                    rect = createRectPath(0, 40, 80),
                    triangle = createTrianglePath(235, 40, 80),
                    element,
                    attributes = [ { path: rect, stroke: black, fill: red },
                                   { path: triangle, stroke: black, fill: green } ],
                    which = 1;

                paper.arrow(140, 80);
                paper.text(140, 60, "Node.js").attr({ font: "18px 'Helvetica Neue', Arial", fill: white });

                paper.path(rect).attr(dashed);
                paper.path(triangle).attr(dashed);

                element = paper.path(rect).attr({ "stroke": black, "fill": red });

                setInterval(function() {
                  element.stop().animate(attributes[+(which = !which)], 2000);
                }, 3000);
              } ());
            </script>
          </section>

        </section>

        <section>

          <section>
            <h1>Contra</h1>
            <aside class="notes">
              <ul>
                <li>Teraz sytuacje w których decyzja o postawieniu na Node.js jest ewidentnym błędem.</li>
                <li>Wprowadzi ona więcej problemów niż korzyści.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Aplikacje intensywnie wykorzystujące CPU</h2>
            <br/>
            <div id="cpu-bound"></div>
            <div id="gauge"></div>
            <aside class="notes">
              <ul>
                <li>Aplikacje operujące na wideo / audio - kompresja / dekompresja, kodowanie i dekodowanie itp.</li>
                <li>Wymagające intensywnych zasobów CPU, typowo obliczeniowe.</li>
                <li>Przez budowę Node i pętlę zdarzeń wszelkie obliczenia działają w głównym wątku.</li>
                <li>To prosta droga do zablokowania całego procesu, ponieważ obliczenia wykonują się synchronicznie.</li>
                <li>Blokujemy w ten sposób obsługę pozostałych żądań.</li>
              </ul>
            </aside>
            <script>
              (function() {
                function getRandomArbitary(min, max) {
                  return Math.random() * (max - min) + min;
                }

                var cpu = Raphael("cpu-bound", 300, 300),
                    gauge = Raphael("gauge", 230, 230),
                    speedo = gauge.tachometer(85, {
                      interactive: true,
                      numberMargin: 30,
                      needleAnimationDuration: 400,
                      number: false,
                      needleAnimationEasing: "easy-in"
                    }),
                    font = function(color) {
                      return {
                        "font": "14px 'Helvetica Neue', Arial",
                        "font-weight": "bold",
                        "fill": color
                      };
                    },
                    which = 1,
                    steps = [],
                    rejectedArrow;

                gauge.text(118, 75, "Zużycie CPU\nw procentach").attr(font(white));

                cpu.rect(120, 40, 160, 160).attr({ fill: white });

                cpu.text(200, 60, "Serwer\nNode.js").attr(font(black));
                cpu.text(70, 62, "Żądania").attr(font(white));

                cpu.rightArrow(70, 80).attr({ fill: green });
                rejectedArrow = cpu.rightArrow(50, 160).attr({ fill: red });

                steps.push({ path: createRightArrowPath(50, 160), fill: red });
                steps.push({ path: createRightArrowPath(70, 160), fill: gray });

                setInterval(function() {
                  speedo.set(getRandomArbitary(90, 100));

                  rejectedArrow.stop().animate(steps[+(which = !which)], 200);
                }, 1000);
              } ());
            </script>
          </section>

          <section>
            <h2>Aplikacje typu <em>CRUD</em> / <em>CMS</em></h2>
            <aside class="notes">
              <ul>
                <li>CRUD / CMS w Node.js - można, tylko po co wynajdywać koło na nowo.</li>
                <li>Prowokujemy powstawanie błędów, przechodzimy ewolucję którą ktoś już przeszedł jeszcze raz.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Moda</h2>
            <h4 class="fragment"><em>Magic-Unicorn-NoSQL-Async-Non-Blocking-I/O<br/>Buzzwords Bullshit</em></h4>
            <aside class="notes">
              <ul>
                <li>Kierowanie się modą i "zachłystywanie".</li>
                <li>Zawsze błędna strategia.</li>
                <li>Brak perspektywy, nieznajomość rozwiązania -> wykorzystanie technologii w złym kontekście.</li>
                <li>Context is a king!</li>
                <li>Kontrast: solidne, skalowalne, niepopularne rozwiązanie - Erlang / OTP.</li>
                <li>Dlaczego nie? Dla wielu dziwna składnia (Prolog), funkcyjny język, branża telekomunikacyjna.</li>
                <li>Bardzo często dużo bardziej skalowalne, stabilne rozwiązanie ale skrajnie niepopularne.</li>
                <li>Przez to wykorzystywane tylko w dobrym kontekście, uniknęło "mody".</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section data-background-color="#33342C">
            <h1>Kto?</h1>
            <ul id="random">
              <li><img src="img/paypal-logo.jpg" alt="PayPal Logo" /></li>
              <li><img src="img/microsoft-logo.png" alt="Microsoft Logo" /></li>
              <li><img src="img/ebay-logo.png" alt="eBay Logo" /></li>
              <li><img src="img/voxer-logo.png" alt="Voxer Logo" /></li>
              <li><img src="img/linkedin-logo.png" alt="LinkedIn Logo" /></li>
              <li><img src="img/uber-logo.png" alt="Uber Logo" /></li>
              <li><img src="img/nodejitsu-logo.png" alt="Nodejitsu Logo" /></li>
              <li><img src="img/cloud9-logo.png" alt="Cloud9 IDE Logo"></li>
              <li><img src="img/yahoo-logo.png" alt="Yahoo! Logo"></li>
              <li><img src="img/strongloop-logo.png" alt="StrongLoop Logo"></li>
              <li><img src="img/nytimes-logo.png" alt="NY Times Logo"></li>
              <li><img src="img/transloadit-logo.png" alt="Transloadit Logo"></li>
              <li><img src="img/backbeam-logo.png" alt="backbeam Logo"></li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Całkiem imponujący zbiór.</li>
                <li>Potęgi - eBay, PayPal, Microsoft, Yahoo.</li>
                <li>Start-upy - Voxer, Transloadit, Backbeam.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Success Stories</h2>
            <ul>
              <li class="fragment">Lekkość prototypowania</li>
              <li class="fragment">Asynchroniczna obsługa wejścia - wyjścia</li>
              <li class="fragment">Intensywne wykorzystanie Web Sockets</li>
              <li class="fragment">Strumieniowanie danych</b></li>
              <li class="fragment">API typu REST oparte o transport JSON</li>
              <li class="fragment">Narzędzia konsolowe (<em>grunt</em>, <em>bower</em>, <em>yeoman</em>)</li>
              <li class="fragment">Aplikacje desktopowe (moduł <em>node-webkit</em> - LightTable)</li>
              <li class="fragment">Reveal.js oraz <a href="http://slid.es" target="_blank">slid.es</a></li>
            </ul>
            <aside class="notes">
              <ul>
                <li>Lekkość - to właśnie przypadek PayPala ("usztywniony" rozwój aplikacji opartej o JSP/Java).</li>
                <li>Project Kraken.</li>
                <li>Nie mylić strumieniowania z dekodowaniem / kodowaniem strumienia danych!</li>
                <li>Bardzo dobrym rozwiązanie: prototypowanie na Node.js, ewolucja na stabilniejszą technologię.</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section>
            <h1>Co jeszcze?</h1>
            <aside class="notes">
              <ul>
                <li>Czy Node.js ma do zaoferowania coś więcej?</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>libuv</h2>
            <p>
              Jest to biblioteka napisana w języku C, która wprowadza warstwę abstrakcji dla nieblokujących operacji wejścia-wyjścia, która jest niezależna od systemu operacyjnego.
            </p>
            <aside class="notes">
              <ul>
                <li>Nieblokujące API dla operacji wejścia - wyjścia.</li>
                <li>Asynchroniczna obsługa protokołów TCP, DNS, która jest niezależna od systemu operacyjnego.</li>
                <li>Najważniejsza warstwa abstrakcji, drugi pod względem ważności komponent po V8.</li>
                <li>CIEKAWOSTKA: IOCP (I/O Completion Ports) na Windowsie.</li>
                <li>CIEKAWOSTKA: epoll/kqueue/dev-poll/event ports na systemach Unixowych i pochodnych.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>NPM</h2>
            <h3>Node Packaged Modules</h3>
            <p>
              Sam rdzeń platformy jest bardzo cienki, więc moduły przygotowane przez społeczność są bardzo ważnym elementem.
            </p>
            <strong>Codziennie powstaje 97 nowych modułów.</strong>
            <table id="data">
              <tfoot>
                <tr>
                  <th>September 2011</th>
                  <th>September 2012</th>
                  <th>September 2013</th>
                </tr>
              </tfoot>
              <tbody>
                <tr>
                  <td>4700</td>
                  <td>15000</td>
                  <td>42000</td>
                </tr>
              </tbody>
            </table>
            <div id="chart"></div>
            <p class="fragment">
              Oczywiście nigdy nie jest tak dobrze, żeby nie mogło być lepiej.
            </p>
            <aside class="notes">
              <ul>
                <li>NPM = Maven, NuGet, gem, pip.</li>
                <li>Ilość modułów = Olbrzymia.</li>
                <li>Tempo rozwoju = Olbrzymie.</li>
                <li>Tempo rozwoju wcale nie zwalnia, co możemy zauważyć na interaktywnej animacji.</li>
                <li>Niestety, przeważnie taka ilość nie zawsze przekłada się na jakość.</li>
                <li>Główni opiekunowie całego projektu mają jednak masę pomysłów jak olbrzymią ilość danych.</li>
                <li>Budują oni system ocen, oparty zarówno na ocenie kodu, testów, feedbacku, wykorzystaniu.</li>
                <li>Dzięki temu łatwo będzie odnaleźć najlepsze moduły realizujące daną funkcjonalność.</li>
                <li>Niestety nie ma róży bez kolców.</li>
                <li>Oprócz "klęski urodzaju" - chodzi o ilość modułów największym problemem jest dostępność repozytorium.</li>
                <li>Problemy z samym menadżerem w wersji 0.8 (zespół Parkeon France doskonale wie o co chodzi).</li>
                <li>Połączenie prywatnego repozytorium z globalnym kuleje np. problem z publikowaniem paczek.</li>
                <li>Pomysł oddania władzy w ręce społeczności jest bardzo dobry.</li>
                <li>Wręcz genialny jeśli zauważymy, że opiekunowie muszą skupić się na dopracowaniu małej części.</li>
                <li>Niestety wymienione problemy pozostawiają skazę na bardzo ciekawym rozwiązaniu.</li>
                <li>Pocieszeniem jest to, że opiekunowie o tym wiedzą i pracują nad poprawieniem sytuacji.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Unix Philosophy</h2>
            <p class="justified-to-left">
              <em>
                Write programs that do one thing and do it well.<br/>
                Write programs to work together.<br/>
                Write programs to handle streams.<br/>
              </em>
            </p>
            <aside class="notes">
              <ul>
                <li>Node.js posiada bardzo chudy rdzeń - co jest zgodne z filozofią narzędzi unixowych.</li>
                <li>Właśnie dzięki połączeniu narzędzi otrzymujemy bardzo potężne rozwiązania.</li>
                <li>Mamy jednocześnie pewność, że fragmenty są dobrze zmodularyzowane i działają poprawnie.</li>
                <li>Zaleca się aby budować moduły Node.js w identyczny sposób.</li>
                <li>Jako bardzo małe, skupiające się tylko na jednej rzeczy.</li>
                <li>Dodatkowym potwierdzeniem tej filozofii jest stosunek głównych opiekunów do rozszerzeń rdzenia.</li>
                <li>Co rusz pojawiają się propozycje o dodanie pewnej funkcjonalności jako części platformy.</li>
                <li>To spotyka się ze słusznym oporem ze strony Isaaca i innych opiekunów.</li>
                <li>Lepiej robić jedną rzecz, ale najlepiej - prawda? ;)</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>ECMAScript 5 oraz 6</h2>
            <pre>
              <code data-trim class="bash">
# Node.js w wersji 0.11.2
$ node --v8-options | grep harmony
  --harmony_typeof
  --harmony_scoping
  --harmony_modules
  --harmony_symbols
  --harmony_proxies
  --harmony_collections
  --harmony_observation
  --harmony_typed_arrays
  --harmony_array_buffer
  --harmony_generators
              </code>
            </pre>
            <aside class="notes">
              <ul>
                <li>Jeden silnik JavaScript (V8) - możemy korzystać z pełni możliwości!</li>
                <li>A jest w czym wybierać ponieważ V8 jest w pełni zgodny z ECMAScript 5.1.</li>
                <li>I jest szybko aktualizowany o najnowsze elementy wprowadzone w najnowszej specyfikacji języka.</li>
                <li>Harmony to nazwa nowej specyfikacji ECMAScript 6.</li>
                <li>Moduły, kolekcje, możliwości obserwacji zmian prostych obiektów, silnie typowane tablice.</li>
                <li>Wsparcie asynchronicznych operacji wbudowane w składnię języka (Generators).</li>
                <li>Programowanie aspektowe (Proxy).</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>
          <h1>Pytania?</h1>
        </section>

        <section>
          <h2>Dziękuję za uwagę!</h2>
          <h4>Odniesienia dla <em>ciekawskich</em></h4>
          <ul class="links">
            <li>
              <a href="http://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition">
                Model nabywania kompetencji braci <em>Dreyfus</em>
              </a>
            </li>
            <li>
              <a href="http://www.kegel.com/c10k.html">
                <em>Problem c10k</em>
              </a>
            </li>
            <li>
              <a href="http://www.joyent.com/technology/smartos">
                <em>Smart OS</em>
              </a>
            </li>
            <li>
              <a href="http://en.wikipedia.org/wiki/Mashup_(web_application_hybrid)">
                <em>Mashup</em>
              </a>
            </li>
            <li>
              <a href="http://www.youtube.com/watch?v=tZWGb0HU2QM">
                Clash of the Titans: Releasing the Kraken (<em>Node.js at PayPal</em>)
              </a>
            </li>
            <li>
              <a href="http://www.chris-granger.com/2013/01/24/the-ide-as-data/">
                <em>Light Table</em>
              </a>
            </li>
            <li>
              <a href="http://lab.hakim.se/reveal-js/#/">
                <em>Reveal.js</em>
              </a>
            </li>
            <li>
              <a href="http://semver.org/">
                <em>Semantic Versioning</em>
              </a>
            </li>
            <li>
              <a href="http://blogs.teamb.com/craigstuntz/2008/05/19/37819/">
                Erlang i filozofia <em>Let it Crash&nbsp;</em>
              </a>
            </li>
            <li>
              <a href="http://nodeschool.io">
                Jak rozpocząć przygodę z Node.js (<em>nodeschool.io</em>) ?
              </a>
            </li>
            <li>
              <a href="http://www.modulecounts.com/"><em>Module Counts</em></a>
            </li>
          </ul>
          <h4 class="spaced-max half-sized">Wykorzystane obrazy pochodzą ze stron:</h4>
          <ul class="photo-credits">
            <li>
              <a href="http://nodejs.org/industry">
                <em>Node.js Industry Page</em>
              </a>
            </li>
            <li>
              <a href="http://www.flickr.com/photos/cjmartin">
                <em>Flickr - cjmartin</em>
              </a>
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: "default",
        transition: "linear",
        backgroundTransition: "slide",

        dependencies: [
          {
            src: "lib/js/classList.js",condition: function() { return !document.body.classList; }
          },
          {
            src: "plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); }
          },
          {
            src: "plugin/zoom-js/zoom.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "plugin/notes/notes.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "socket.io/socket.io.js", async: true
          },
          {
            src: "plugin/notes-server/client.js", async: true
          }
        ]
      });

    </script>
  </body>
</html>
