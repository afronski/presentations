<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Podstawy profilowania i analiza wydajności aplikacji webowych</title>

    <meta name="description" content="Podstawy profilowania i analiza wydajności aplikacji webowych">
    <meta name="author" content="Wojciech Gawroński">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link href="http://fonts.googleapis.com/css?family=Roboto+Slab|Roboto&subset=latin,latin-ext"
          rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/TangleKit.css" />
    <link rel="stylesheet" href="css/theme/default.css" id="theme" />

    <link rel="stylesheet" href="lib/css/github.css" />

    <script src="js/raphael.js"></script>
    <script src="js/raphael.group.js"></script>
    <script src="js/raphael.tachometer.min.js"></script>
    <script src="js/analytics.js"></script>
    <script src="js/popup.js"></script>
    <script src="js/Tangle.js"></script>
    <script src="js/mootools.js"></script>
    <script src="js/sprintf.js"></script>
    <script src="js/BVTouchable.js"></script>
    <script src="js/TangleKit.js"></script>
    <script>
      var RAD = Math.PI / 180;

      function getRandomArbitary(min, max) {
        return Math.random() * (max - min) + min;
      }

      function createRectPath(x, y, a) {
        return "M" + x + "," + y + "l" + a + ",0 0," + a + "-" + a + ",0z";
      }

      function createTrianglePath(x, y, a) {
        return "M" + x + "," + y + "l" + a / 2 + "," + a + " -" + a + ",0z";
      }

      function createRightArrowPath(x, y) {
        return "M" + x + "," + y + "m-10-10l40,0 0-6 20,16 -20,16 0-6 -40,0 -0-16z"
      }

      function createArcPath(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.cos(-startAngle * RAD),
            x2 = cx + r * Math.cos(-endAngle * RAD),
            y1 = cy + r * Math.sin(-startAngle * RAD),
            y2 = cy + r * Math.sin(-endAngle * RAD);

        return ["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"];
      }

      function spinner(r, centerx, centery, spinnerId, R1, R2, count, stroke_width, colour) {
        var sectorsCount = count || 12,
            color = colour || "#888",
            group = r.group(),
            width = stroke_width || 5,
            r1 = Math.min(R1, R2) || 10,
            r2 = Math.max(R1, R2) || 25,
            cx = centerx + r2 + width,
            cy = centery + r2 + width,

            sectors = [],
            opacity = [],
            beta = 2 * Math.PI / sectorsCount,

            pathParams = { stroke: color, "stroke-width": width, "stroke-linecap": "round" };

        Raphael.getColor.reset();

        if (spinnerId) {
          group.id(spinnerId);
        }

        for (var i = 0; i < sectorsCount; i++) {
          var alpha = beta * i - Math.PI / 2,
              cos = Math.cos(alpha),
              sin = Math.sin(alpha);

          opacity[i] = 1 / sectorsCount * i;
          sectors[i] = r.path([["M", cx + r1 * cos, cy + r1 * sin], ["L", cx + r2 * cos, cy + r2 * sin]])
                        .attr(pathParams);

          group.push(sectors[i]);

          sectors[i].attr("data-name", "sectors");

          if (color == "rainbow") {
            sectors[i].attr("stroke", Raphael.getColor());
          }
        }

        var tick;

        (function ticker() {
          opacity.unshift(opacity.pop());

          for (var i = 0; i < sectorsCount; i++) {
            sectors[i].attr("opacity", opacity[i]);
          }

          r.safari();
          tick = setTimeout(ticker, 1000 / sectorsCount);
        } ());

        return function () {
          clearTimeout(tick);

          for (var i = 0; i < sectorsCount; i++) {
            sectors[i].remove();
          }
        };
      }

      Raphael.fn.arrow = function (x, y) {
          return this.path(["M", x, y ] + "m-10-10l20,0 0-6 10,16 -10,16 0-6 -20,0 0,6 -10-16 10-16z")
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.2 });
      };

      Raphael.fn.rightArrow = function (x, y) {
          return this.path(createRightArrowPath(x, y))
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.5 });
      };

      Raphael.fn.thinArrow = function(x1, y1, x2, y2, size) {
        var angle = Raphael.angle(x1, y1, x2, y2);
            a45   = Raphael.rad(angle - 45),
            a45m  = Raphael.rad(angle + 45),
            a135  = Raphael.rad(angle - 135),
            a135m = Raphael.rad(angle + 135),
            x1a = x1 + Math.cos(a135) * size,
            y1a = y1 + Math.sin(a135) * size,
            x1b = x1 + Math.cos(a135m) * size,
            y1b = y1 + Math.sin(a135m) * size,
            x2a = x2 + Math.cos(a45) * size,
            y2a = y2 + Math.sin(a45) * size,
            x2b = x2 + Math.cos(a45m) * size,
            y2b = y2 + Math.sin(a45m) * size;

        return this.path("M" + x1 + " " + y1 + "L" + x1a + " " + y1a + "M" + x1 + " " + y1 + "L" + x1b + " " + y1b +
                         "M" + x1 + " " + y1 + "L" + x2 +  " " + y2 +
                         "M" + x2 + " " + y2 + "L" + x2a + " " + y2a + "M" + x2 + " " + y2 + "L" + x2b + " " + y2b);
      };

      var dashed = { fill: "none", stroke: "#666", "stroke-dasharray": "- " },
          black = "#333",
          gray = "#888",
          white = "#ffffff",
          red = "#ff0000",
          green = "#00ff00",
          yellow = "#ffff00",
          lightBlue = "#00ffff",
          nodeGreen = "#8CC84B";
    </script>
    <script>
      document.write("<link rel='stylesheet' href='css/print/" +
                     (window.location.search.match(/print-pdf/gi) ? "pdf" : "paper") +
                    ".css' type='text/css' media='print'>");
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Podstawy profilowania<br/>i analiza wydajności aplikacji webowych</h2>
          <div id="gauge"></div>

          <span class="license">
            Licencja: <a href="http://creativecommons.org/licenses/by-nd/3.0/pl/">CC BY-ND 3.0 PL</a>
          </span>

          <aside class="notes">
            <ul>
              <li>
                Witam Was na szkoleniu dotyczącym profilowania i analizy wydajności aplikacji webowych. Przez 1.5 godziny będę chciał zaprezentować wam teoretyczne podstawy badania wydajności aplikacji webowych, przybliżyć najpopularniejsze narzędzia oraz zaprezentować je w akcji, poprawiając przykładowe problemy.
              </li>
              <li>
                Prezentacja będzie dostępna po szkoleniu.
              </li>
            </ul>
          </aside>

          <script>
            (function() {
              var gauge = Raphael("gauge", 230, 230),
                  speedo = gauge.tachometer(85, {
                    interactive: true,
                    numberMargin: 30,
                    needleAnimationDuration: 400,
                    number: false,
                    needleAnimationEasing: "easy-in"
                  }),
                  font = function(color) {
                    return {
                      "font": "14px 'Helvetica Neue', Arial",
                      "font-weight": "bold",
                      "fill": color
                    };
                  };

              gauge.text(118, 75, "CPU").attr(font(white));
              setInterval(function() { speedo.set(getRandomArbitary(90, 100)); }, 1000);
            } ());
          </script>
        </section>

        <section>

          <section class="section-header">
            <h1>Oznaczenia</h1>

            <aside class="notes">
              <ul>
                <li>
                  Zanim zaczniemy chciałbym porozmawiać o tym jak zbudowana jest prezentacja i jakich oznaczeń będziemy używać.
                </li>
                <li>
                  Niebieski to nagłówki poszczególnych działów.
                </li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h1>Dobre praktyki</h1>

            <aside class="notes">
              <li>
                Dobre praktyki i ważne rzeczy bedą na zielono.
              </li>
            </aside>
          </section>

          <section class="warning">
            <h1>Ostrzeżenie!<h1>

            <aside class="notes">
              <ul>
                <li>
                  Ostrzeżenia i miejsca na które warto zwrócić uwagę oznaczymy kolorem żółtym.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h1>Złe przykłady</h1>

            <aside class="notes">
              <ul>
                <li>
                  Błędne podejście oznaczymy sobie kolorem pomarańczowym.
                </li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Budowa przeglądarki</h1>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Narzędzia</h1>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Benchmarki</h1>

            <aside class="notes">
              Chciałbym zająć się teraz trudną sztuką tworzenia benchmarków. Jest to zagadnienie tak obszerne, że naprawdę można mu poświęcić całą nową prezentację, natomiast ja chciałbym pokazać jak uniknąć najpopularniejszych pułapek przy tworzeniu benchmarków typowo JavaScriptowych i problemów związanych z tą tematyką.
            </aside>
          </section>

          <section class="good">
            <h1>Tryb prywatny</h1>
            <aside class="notes">
              <ul>
                 <li>
                   Zanim przejdziemy do narzędzi. Chciałbym podkreślić najważniejszą rzecz. Najważniejsza jest odpowiednia izolacja takiego benchmarku i w ogóle testów wydajnościowych - najlepiej jest to robić w tzw. trybie prywatnym (incognito).
                 </li>
                 <li>
                   Nie musimy pamiętać o wszystkich elementach które mogą wpływać na nasze testy tj. o pluginach, cache, historii, ustawieniach profilu, ciasteczkach etc.
                 </li>
               </ul>
            </aside>
          </section>

          <section>
            <h1>Narzędzia</h1>
            <ul>
              <li class="fragment"><a href="http://jsperf.com/">jsperf</a></li>
              <li class="fragment"><a href="http://www.browserscope.org/">Browserscope</a></li>
              <li class="fragment">d8, node --profiler</li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  Przejdźmy do narzędzi - najpopularniejszym jest ten przeklęty jsperf. Przeklęty ponieważ jest bardzo łatwy w (nad)użyciu. Prostota stworzenia testu i łatwość współdzielenia wyników przysłania bardzo często zdrowy rozsądek.
                </li>
                <li>
                  O nadużywaniu jsperf opowiemy sobie dokładnie za chwilę.
                </li>
                <li>
                  Inną kategorią narzędzi są strony porównawcze - Browserscope jest najpopularniejszą i najobszerniejszą bazą wiedzy nt. przeglądarek, również związaną z wydajnością.
                </li>
                <li>
                  Ostatnia kategoria to ciężka artyleria czyli tak naprawdę niskopoziomowe profilery dla V8/Node, które umożliwiają dosłownie na spojrzenie pod maskę silnika JavaScript i wykrycia potencjalnych błędów.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h2>Microbenchmarks</h2>
            <pre class="fragment"><code data-trim class="javascript">

            </code></pre>
            <aside class="notes">
              <ul>
                <li>
                  Powiedzieliśmy sobie, że bardzo łatwo nadużyć jsperf. Prowadzi to do zjawiska zw. Microbenchmarkingiem, czyli skupienie na bardzo małych fragmentach kodu i wyciśnięciu z nich siódmych potów.
                </li>
                <li>
                  Problem polega na tym, że środowisko przeglądarkowe nie jest dobrym miejscem do skupiania się na tego typu optymalizacjach, ponieważ mamy zbyt mały wpływ na nie.
                </li>
                <li>
                  W przykładzie widzimy ...
                </li>
                <li>
                  Przez to, że nie mamy praktycznie żadnego wpływu na JIT zostaliśmy oszukani i co gorsza wyciągamy błędne wnioski.
                </li>
              </ul>
            </aside>
          </section>

          <section class="warning">
            <h2>Jak to naprawić?</h2>
            <pre class="fragment"><code data-trim class="javascript">

            </code></pre>
            <aside class="notes">
              <ul>
                <li>
                  Oto jak musimy poprawić nasz benchmark ...
                </li>
                <li>
                  Ważniejsze jednak do tego jak to naprawić, jest zupełnie co innego. Powinniśmy skupiać się raczej na profilowaniu całości i optymalizacji całego rozwiązania, niż wyszukiwać który sposób łączenia łańcuchów tekstowych jest najoptymalniejszy dla przeglądarki (za dużo przeglądarek, zbyt mały wpływ na środowisko, od tego jest JIT).
                </li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h2>Don't take performance advices from strangers!</h2>
            <h4><a href="https://github.com/felixge/faster-than-c">Felix Geisendörfer</a></h4>
            <aside class="notes">
              Na koniec dwie bardzo ważne rady - nie przyjmujmy rad dot. wydajności od obcych na ślepo. Nie szukajmy w internecie, na blogach, na forach odpowiedzi na Nasze pytania - to My znamy system i My powinniśmy go zbadać.
            </aside>
          </section>

          <section class="good">
            <h2>Don't guess it, test it!</h2>
            <h4><a href="http://www.aerotwist.com/blog/dont-guess-it-test-it/">Paul Lewis</a></h4>
            <aside class="notes">
              Właśnie! Najpierw zbadać, potem poprawić - najpierw zmierzyć potem uciąć. Nie powinniśmy tym bardziej strzelać na oślep technikami optymalizacyjnymi (zasada Pareto 80/20 ma wszędzie zastosowanie).
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Case Studies</h1>
          </section>

          <section>
            <h2>JavaScript</h2>
          </section>

          <section>
            <h1>Pamięć</h1>
          </section>

          <section>
            <h1>DOM</h1>
          </section>

          <section>
            <h1>Sieć</h1>
          </section>

        </section>

        <section class="section-header">
          <h1>Pytania?</h1>
        </section>

        <section class="section-header">
          <h2>Dziękuję za uwagę!</h2>
          <h4>Odniesienia dla <em>ciekawskich </em>:</h4>
          <ul class="links">
            <li>
              <a href="http://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html">
                Microbenchmarks fairy tale
              </a>
            </li>
            <li>
              <a href="http://www.youtube.com/watch?v=65-RbBwZQdU">
                Performance and benchmarking
              </a>
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      var BLUE = "#63ABF0",
          RED = "#FA5F0C",
          GREEN = "#52A617",
          YELLOW = "#FFC03C";

      Function.prototype.curry = function() {
        var fn = this,
            args = [].slice.call(arguments);

        return function() {
          return fn.apply(this, args.concat([].slice.call(arguments)));
        };
      };

      function getArrayOfDomElements(selector) {
        return [].slice.call(document.querySelectorAll(selector));
      }

      function applyColor(color, element) {
        element.setAttribute("data-background", color);
      }

      getArrayOfDomElements(".section-header").forEach(applyColor.curry(BLUE));
      getArrayOfDomElements(".good").forEach(applyColor.curry(GREEN));
      getArrayOfDomElements(".bad").forEach(applyColor.curry(RED));
      getArrayOfDomElements(".warning").forEach(applyColor.curry(YELLOW));

      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: "default",
        transition: "slide",
        transitionSpeed: "fast",
        backgroundTransition: "linear",

        dependencies: [
          {
            src: "lib/js/classList.js",condition: function() { return !document.body.classList; }
          },
          {
            src: "plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); }
          },
          {
            src: "plugin/zoom-js/zoom.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "plugin/notes/notes.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "socket.io/socket.io.js", async: true
          },
          {
            src: "plugin/notes-server/client.js", async: true
          }
        ]
      });
    </script>
  </body>
</html>