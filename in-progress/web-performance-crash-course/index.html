<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Podstawy profilowania i analiza wydajności aplikacji webowych</title>

    <meta name="description" content="Podstawy profilowania i analiza wydajności aplikacji webowych">
    <meta name="author" content="Wojciech Gawroński">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link href="http://fonts.googleapis.com/css?family=Roboto+Slab|Roboto&subset=latin,latin-ext"
          rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/TangleKit.css" />
    <link rel="stylesheet" href="css/theme/default.css" id="theme" />

    <link rel="stylesheet" href="lib/css/github.css" />

    <script src="js/raphael.js"></script>
    <script src="js/raphael.group.js"></script>
    <script src="js/raphael.tachometer.min.js"></script>
    <!-- <script src="js/analytics.js"></script> -->
    <script src="js/popup.js"></script>
    <script src="js/Tangle.js"></script>
    <script src="js/mootools.js"></script>
    <script src="js/sprintf.js"></script>
    <script src="js/BVTouchable.js"></script>
    <script src="js/TangleKit.js"></script>
    <script>
      var RAD = Math.PI / 180;

      function getRandomArbitary(min, max) {
        return Math.random() * (max - min) + min;
      }

      function createRectPath(x, y, a) {
        return "M" + x + "," + y + "l" + a + ",0 0," + a + "-" + a + ",0z";
      }

      function createTrianglePath(x, y, a) {
        return "M" + x + "," + y + "l" + a / 2 + "," + a + " -" + a + ",0z";
      }

      function createRightArrowPath(x, y) {
        return "M" + x + "," + y + "m-10-10l40,0 0-6 20,16 -20,16 0-6 -40,0 -0-16z"
      }

      function createGearboxPath() {
        return "M295.186,122.908c12.434,18.149,32.781,18.149,45.215,0l12.152-17.736c12.434-18.149,22.109-15.005,21.5,6.986l-0.596,21.49c-0.609,21.992,15.852,33.952,36.579,26.578l20.257-7.207c20.728-7.375,26.707,0.856,13.288,18.29l-13.113,17.037c-13.419,17.434-7.132,36.784,13.971,43.001l20.624,6.076c21.103,6.217,21.103,16.391,0,22.608l-20.624,6.076c-21.103,6.217-27.39,25.567-13.971,43.001l13.113,17.037c13.419,17.434,7.439,25.664-13.287,18.289l-20.259-7.207c-20.727-7.375-37.188,4.585-36.578,26.576l0.596,21.492c0.609,21.991-9.066,25.135-21.5,6.986L340.4,374.543c-12.434-18.148-32.781-18.148-45.215,0.001l-12.152,17.736c-12.434,18.149-22.109,15.006-21.5-6.985l0.595-21.492c0.609-21.991-15.851-33.951-36.578-26.576l-20.257,7.207c-20.727,7.375-26.707-0.855-13.288-18.29l13.112-17.035c13.419-17.435,7.132-36.785-13.972-43.002l-20.623-6.076c-21.104-6.217-21.104-16.391,0-22.608l20.623-6.076c21.104-6.217,27.391-25.568,13.972-43.002l-13.112-17.036c-13.419-17.434-7.439-25.664,13.288-18.29l20.256,7.207c20.728,7.374,37.188-4.585,36.579-26.577l-0.595-21.49c-0.609-21.992,9.066-25.136,21.5-6.986L295.186,122.908z";
      }

      function font(color) {
        return {
          "font": "18px 'Helvetica Neue', Arial",
          "font-weight": "bold",
          "fill": color
        };
      }

      function createArcPath(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.cos(-startAngle * RAD),
            x2 = cx + r * Math.cos(-endAngle * RAD),
            y1 = cy + r * Math.sin(-startAngle * RAD),
            y2 = cy + r * Math.sin(-endAngle * RAD);

        return ["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"];
      }

      function spinner(r, centerx, centery, spinnerId, R1, R2, count, stroke_width, colour) {
        var sectorsCount = count || 12,
            color = colour || "#888",
            group = r.group(),
            width = stroke_width || 5,
            r1 = Math.min(R1, R2) || 10,
            r2 = Math.max(R1, R2) || 25,
            cx = centerx + r2 + width,
            cy = centery + r2 + width,

            sectors = [],
            opacity = [],
            beta = 2 * Math.PI / sectorsCount,

            pathParams = { stroke: color, "stroke-width": width, "stroke-linecap": "round" };

        Raphael.getColor.reset();

        if (spinnerId) {
          group.id(spinnerId);
        }

        for (var i = 0; i < sectorsCount; i++) {
          var alpha = beta * i - Math.PI / 2,
              cos = Math.cos(alpha),
              sin = Math.sin(alpha);

          opacity[i] = 1 / sectorsCount * i;
          sectors[i] = r.path([["M", cx + r1 * cos, cy + r1 * sin], ["L", cx + r2 * cos, cy + r2 * sin]])
                        .attr(pathParams);

          group.push(sectors[i]);

          sectors[i].attr("data-name", "sectors");

          if (color == "rainbow") {
            sectors[i].attr("stroke", Raphael.getColor());
          }
        }

        var tick;

        (function ticker() {
          opacity.unshift(opacity.pop());

          for (var i = 0; i < sectorsCount; i++) {
            sectors[i].attr("opacity", opacity[i]);
          }

          r.safari();
          tick = setTimeout(ticker, 1000 / sectorsCount);
        } ());

        return function () {
          clearTimeout(tick);

          for (var i = 0; i < sectorsCount; i++) {
            sectors[i].remove();
          }
        };
      }

      Raphael.fn.arrow = function (x, y) {
          return this.path(["M", x, y ] + "m-10-10l20,0 0-6 10,16 -10,16 0-6 -20,0 0,6 -10-16 10-16z")
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.2 });
      };

      Raphael.fn.rightArrow = function (x, y) {
          return this.path(createRightArrowPath(x, y))
                     .attr({ fill: "#fff", stroke: "none", "stroke-dasharray": "-", "fill-opacity": 0.5 });
      };

      Raphael.fn.gearBox = function() {
          return this.path(createGearboxPath())
                     .attr({ stroke: "#666", opacity: 0.9, "stroke-width": 10 });
      };

      Raphael.fn.thinArrow = function(x1, y1, x2, y2, size) {
        var angle = Raphael.angle(x1, y1, x2, y2);
            a45   = Raphael.rad(angle - 45),
            a45m  = Raphael.rad(angle + 45),
            a135  = Raphael.rad(angle - 135),
            a135m = Raphael.rad(angle + 135),
            x1a = x1 + Math.cos(a135) * size,
            y1a = y1 + Math.sin(a135) * size,
            x1b = x1 + Math.cos(a135m) * size,
            y1b = y1 + Math.sin(a135m) * size,
            x2a = x2 + Math.cos(a45) * size,
            y2a = y2 + Math.sin(a45) * size,
            x2b = x2 + Math.cos(a45m) * size,
            y2b = y2 + Math.sin(a45m) * size;

        return this.path("M" + x1 + " " + y1 + "L" + x1a + " " + y1a + "M" + x1 + " " + y1 + "L" + x1b + " " + y1b +
                         "M" + x1 + " " + y1 + "L" + x2 +  " " + y2 +
                         "M" + x2 + " " + y2 + "L" + x2a + " " + y2a + "M" + x2 + " " + y2 + "L" + x2b + " " + y2b);
      };

      Raphael.fn.drawAnnotatedSlice = function(x, y, size, text, color, width, yOffset) {
        var height = 20;

        width = width || 1;
        yOffset = yOffset || 0;

        this.text(x + (size / 2), y - 65 - yOffset, text).attr(font(white));

        this.path("M" + x + " " + y + "L" + (x + size) + " " + y).attr({ "stroke": color, "stroke-width": 10 });

        this.path("M" + (x + size) + " " + (y - height) + "L" + (x + size) + " " + (y + height))
            .attr({ "stroke": color, "stroke-width": width });

        this.path("M" + x + " " + (y - height) + "L" + x + " " + (y + height))
            .attr({ "stroke": color, "stroke-width": width });
      };

      var dashed = { fill: "none", stroke: "#666", "stroke-dasharray": "- " },
          black = "#333",
          gray = "#888",
          white = "#ffffff",
          red = "#ff0000",
          green = "#00ff00",
          yellow = "#ffff00",
          lightBlue = "#00ffff",
          nodeGreen = "#8CC84B";
    </script>
    <script>
      document.write("<link rel='stylesheet' href='css/print/" +
                     (window.location.search.match(/print-pdf/gi) ? "pdf" : "paper") +
                    ".css' type='text/css' media='print'>");
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Podstawy profilowania<br/>i analiza wydajności aplikacji webowych</h2>
          <div id="gauge"></div>

          <span class="license">
            Licencja: <a href="http://creativecommons.org/licenses/by-nd/3.0/pl/">CC BY-ND 3.0 PL</a>
          </span>

          <aside class="notes">
            <ul>
              <li>
                Witam Was na szkoleniu dotyczącym profilowania i analizy wydajności aplikacji webowych. Przez 1.5 godziny będę chciał zaprezentować wam teoretyczne podstawy badania wydajności aplikacji webowych, oraz będę chciał Wam przybliżyć najpopularniejsze narzędzia i techniki oraz zaprezentować je w akcji, poprawiając przykładowe problemy.
              </li>
              <li>
                Prezentacja będzie dostępna po szkoleniu.
              </li>
            </ul>
          </aside>

          <script>
            (function() {
              var gauge = Raphael("gauge", 230, 230),
                  speedo = gauge.tachometer(85, {
                    interactive: true,
                    numberMargin: 30,
                    needleAnimationDuration: 400,
                    number: false,
                    needleAnimationEasing: "easy-in"
                  });

              gauge.text(118, 75, "CPU").attr(font(white));
              setInterval(function() { speedo.set(getRandomArbitary(90, 100)); }, 1000);
            } ());
          </script>
        </section>

        <section>

          <section class="section-header">
            <h1>Oznaczenia</h1>

            <aside class="notes">
              <ul>
                <li>
                  Zanim zaczniemy chciałbym porozmawiać o tym jak zbudowana jest prezentacja i jakich oznaczeń będziemy używać.
                </li>
                <li>
                  Niebieski to nagłówki poszczególnych działów.
                </li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h1>Dobre praktyki</h1>

            <aside class="notes">
              <li>
                Dobre praktyki i ważne rzeczy bedą na zielono.
              </li>
            </aside>
          </section>

          <section class="warning">
            <h1>Ostrzeżenie!<h1>

            <aside class="notes">
              <ul>
                <li>
                  Ostrzeżenia i miejsca na które warto zwrócić uwagę oznaczymy kolorem żółtym.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h1>Złe przykłady</h1>

            <aside class="notes">
              <ul>
                <li>
                  Błędne podejście oznaczymy sobie kolorem pomarańczowym.
                </li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h2>Wprowadzenie</h2>
            <aside class="notes">
              <ul>
                <li>Na początku chciałbym odpowiedzieć na jedno bardzo ważne pytanie.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Co to znaczy <em>szybko </em>?</h2>
            <div id="delays">
              <table>
                <thead>
                  <tr><th class="delay">Opóźnienie</th><th class="reaction">Reakcja użytkownika</th></tr>
                </thead>
                <tbody>
                  <tr><td class="delay">0 - 100 ms</td><td class="reaction">Błyskawicznie</td></tr>
                  <tr><td class="delay">100 - 300 ms</td><td class="reaction">Minimalne opóźnienie</td></tr>
                  <tr><td class="delay">300 - 1000 ms</td><td class="reaction">Wyczuwalne opóźnienie</td></tr>
                  <tr><td class="delay">&gt; 1 s</td><td class="reaction">Zmiana kontekstu</td></tr>
                  <tr><td class="delay">&gt; 10 s</td><td class="reaction">"Wrócę później..."</td></tr>
                </tbody>
              </table>
            </div>
            <aside class="notes">
              <ul>
                <li>Wyraźnie widać, że każde opóźnienie większe od 1s jest opóźnieniem niedopuszczalnym.</li>
                <li>Użytkownik traci fokus === My tracimy klienta.</li>
                <li>Idealny czas ładowania strony oscyluje w okolicach 1 sekundy.</li>
                <li>Interakcja z UI powinna być poniżej &lt; 100 ms.</li>
                <li>Wszelkie przerwy przeznaczone na wykonywanie operacji powinny być mniejsze od 75 ms.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Co to znaczy <em>płynnie </em>?</h2>
            <h2 id="fps-to-ms">
              <span data-var="fps" data-min="25" data-max="60" data-format="fps" class="TKAdjustableNumber"></span> ===
              <span data-var="ms" data-format="miliseconds"></span>
            </h2>
            <aside class="notes">
              <ul>
                <li>Aby wszystko działało płynnie (60 FPS) kod obsługi rysowania powinno "zmieścić" się w 16.67 ms.</li>
                <li>Omawiana wartość, nazywana jest często budżetem.</li>
                <li>
                  Co ważne - jeśli nie zmieścimy się w podanej wartości powinniśmy utrzymywać stałą długość trwania klatki, ponieważ zmienna wartość czasu wykonania negatywnie wpływa na user experience (skakanie, szarpanie etc).
                </li>
              </ul>
            </aside>

            <script>
              Tangle.formats.fps = function(value) {
                return value + " FPS"
              };

              Tangle.formats.miliseconds = function(value) {
                return value + " ms"
              };

              var tangle = new Tangle(document.querySelector("#fps-to-ms"), {
                    initialize: function () { this.fps = 25; },
                    update:     function () {
                      this.ms = ((1 / this.fps) * 1000.0).toFixed(2);
                    }
                  });
            </script>
          </section>

          <section class="warning">
            <h2>Jak to osiągnąć?</h2>
            <h2 class="fragment">Musimy wiedzieć jak najwięcej o środowisku</h2>
            <aside class="notes">
              <ul>
                <li>
                  Jeśli chcemy osiągnąć czas ładowania bliski 1 sekundy i 60 klatek na sekundę, musimy dokładnie poznać Nasze środowisko, w którym przyjdzie nam działać.
                </li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Budowa przeglądarki</h1>
            <aside class="notes">
              <ul>
                <li>Zapoznajmy się więc z budową przeglądarki.</li>
              </ul>
            </aside>
          </section>

          <section class="warning">
            <h1>Złożoność</h1>
            <h2>
              <span class="smaller pound">10 mln</span> &lt; <span>15 mln</span>
            </h2>
            <span class="browser label">Firefox 26</span>
            <span class="os label">Linux 3.3</span>
            <span class="times label">1.5x</span>

            <aside class="notes">
              <ul>
                <li>Widzimy porównanie wielkości repozytorów pomiędzy Firefox 26 i Linux Kernel w wersji 3.3.</li>
                <li>Przeglądarka zawiera tylko 1.5 raza mniej kodu niż współczesny system operacyjny.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Architektura</h1>
            <h2>Context Switching</h2>

            <div id="slicing"></div>

            <aside class="notes">
              <ul>
                <li>
                  Przeglądarka przełącza się pomiędzy rysowaniem, obsługą wejścia (np. sieci czy zdarzeń z urządzeń wejścia) i wykonaniem kodu JavaScript. Powiedzieliśmy, że aby zapewnić płynność na poziomie 60 FPS, ten "Context Switching" na czas wykonania kodu powinien być krótszy niż 16.67 ms.
                </li>
                <li>Wiele rzeczy pod spodem dzieje się równolegle o czym dokładnie opowiemy sobie za chwilę.</li>
                <li>Na żółto został zaznaczony bardzo ważny moment - synchronizacji rysowania z GPU.</li>
              </ul>
            </aside>

            <script>
              (function() {
                var slicingPaper = Raphael("slicing", 640, 200);

                slicingPaper.text(320, 10, "Kwant czasu - 16.67 ms (60 FPS)").attr(font(white));
                slicingPaper.thinArrow(1, 100, 639, 100, 16).attr({ stroke: white });

                slicingPaper.drawAnnotatedSlice(20, 100, 100, "Wejście", lightBlue);
                slicingPaper.drawAnnotatedSlice(120, 100, 90, "Rysowanie", nodeGreen);
                slicingPaper.drawAnnotatedSlice(210, 100, 10, "VSYNC", yellow, 1, -40);
                slicingPaper.drawAnnotatedSlice(220, 100, 400, "Skrypty", gray);
              } ());
            </script>
          </section>

          <section>
            <img src="img/browser-flow.png" alt="Browser flow" />

            <aside class="notes">
              <ul>
                <li>Widzimy tutaj spojrzenie z lotu ptaka na przepływ danych wewnątrz przeglądarki.</li>
                <li>Kierunek i zależności został pokazany za pomocą strzałek.</li>
                <li>Ogólnie możemy podzielić całość na 3 sekcje: sieć, parsowanie, rysowanie.</li>
              </ul>
            </aside>
          </section>

          <section class="section-header">
            <h1>Sieć</h1>
            <h2>Bandwidth vs. Latency</h2>

            <img src="img/latency.png" alt="Visualization of latency costs" />

            <div class="fragment">Zmniejszenie opóźnienia o 1 ms kosztuje 80 mln $</div>

            <aside class="notes">
              <ul>
                <li>
                  Poza ograniczeniami związanymi bezpośrednio z protokołem, najpoważniejszym Naszym przeciwnikiem jest opóźnienie. Zmniejszenie tego parametru jest bardzo kosztowne, dużo mniej niż zwiększenie przepustowości.
                </li>
                <li>
                  Latencja wpływa na najważniejsze parametry protokołu TCP - ponieważ HTTP jest zbudowany w oparciu o TCP, również i ten protokół cierpi.
                </li>
                <li>
                  Należy jednak pamiętać, że HTTP ma swoje wady (brak multiplexingu dla jednego otwartego połączenia TCP czy nadmierna "gadatliwość" w postaci nagłówków, ciastek etc.).
                </li>
                <li>
                  Nadomiar złego szyfrowanie w postaci SSL wprowadza dodatkowy narzut.
                </li>
                <li>
                  Jest jednak nadzieja na przyszłość - Google pracuje nad SPDY, a IETF pracuje nad HTTP 2.0. Nowa wersja protokołu HTTP właściwie załatwia dużą część optymalizacji o których za chwilę opowiemy. Zainteresowanych zachęcam do lektury linków.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>A co z mobile?</h2>
            <header class="fragment">
              <h3>Jest jeszcze gorzej!</h3>

              <div class="yellow-color">4G - średnie opóźnienie: 150 ms</div>
              <div class="orange-color">3G - średnie opóźnienie: 400 ms</div>
              <h3 class="fragment margin-top">Tryby pracy modemu</h3>
            </header>

            <aside class="notes">
              <ul>
                <li>Sieci komórkowe, ze względu na swoją budowę mają jeszcze większe opóźnienia.</li>
                <li>
                  Co gorsza - modemy 3G / 4G ze względu na swoje zuyżycie energii pracują w różnych trybach i bardzo często zostają uśpione a po wybudzeniu modem musi przejść pełen cykl uwierzytelniania z wieżami transmisyjnymi.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h1>Ilość żądań</h1>

            <img src="img/requests-abusing.png" alt="Too many requests TODO" />

            <aside class="notes">
              <ul>
                <li>Na wykresie widzimy przykład zbyt dużej liczby żądań.</li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h1>Ilość żądań</h1>
            <h2>Optymalizacja</h2>

            <ul>
              <li class="fragment">Dla dużej ilości obrazków używaj techniki <em>sprites </em></li>
              <li class="fragment">Unikaj przekierowań i powolnych serwerów <em>DNS </em></li>
              <li class="fragment">Korzystaj z serwerów <em>CDN </em></li>
              <li class="fragment">Rozprosz zasoby i zastosuj <em>sharding </em></li>
              <li class="fragment">Hostuj statyczne zasoby na osobnym serwerze</li>
              <li class="fragment">Hostuj statyczne zasoby bez <em>SSL </em></li>
              <li class="fragment">Usuwanie ciasteczek i zbędnych nagłówków</li>
              <li class="fragment"><em>HTTP </em> Cache - <em>ETags </em> oraz <em>If-Modified-Since</em></li>
              <li class="fragment">Zmniejsz liczbę osobnych plików <em>*.js </em> oraz <em>*.css </em></li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  Korzystaj z techniki zwanej sprajtami - polega ona na scaleniu wielu obrazów do jednego a następnie wycinanie za pomocą CSS fragmentów z jednego wielkiego obrazu. Dzięki temu zmniejszamy liczbę żądań.
                </li>
                <li>
                  Korzystaj gdzie można z serwerów CDN, uważaj na wolne serwery DNS, unikaj przekierowań.
                </li>
                <li>
                  Stosuj "sharding", czyli rozproszenie zasobów - dzięki serwowaniu różnych zasobów z różnych domen, możliwe będzie wykorzystanie większej liczby połączeń (średnio 6 na domenę).
                </li>
                <li>
                  Hostuj statyczne zasoby (obrazy, arkusze stylów, skrypty, pliki) z osobnego serwera, jeśli nie są wrażliwe z punktu widzenia bezpieczeństwa bez SSL, bez zbędnych ciasteczek, nagłówków, z odpowiednimi nagłówkami ułatwiającymi cacheowanie, oraz połącz skrypty i arkusze stylów w jeden plik.
                </li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h2>Ścieżka krytyczna</h2>

            <img src="img/visualization-of-critical-path.png" alt="Visualization of critical path TODO" />

            <aside class="notes">
              <ul>
                <li>Najlepsza optymalizacja jeśli chodzi o pierwsze ładowanie.</li>
                <li>W przypadku SPA idealne rozwiązanie, bo to pierwszy jedyny page load.</li>
                <li>Polega ona na zoptymalizowaniu strony początkowej tak aby została załadowana maksymalnie w 1s.</li>
                <li>Wszystkie niepotrzebne i dodatkowe funkcjonalności mogą zostać załadowane później.</li>
              </ul>
            </aside>
          </section>

          <section class="section-header">
            <h1>Parsowanie</h1>

            <img src="img/parser.png" alt="Parser workflow" />

            <aside class="notes">
              <ul>
                <li>
                  Od momentu otrzymania pierwszego fragmentu z podsystemu sieciowego przeglądarki uruchamiany jest parser, który przetwarza strumień bajtów na określone tokeny. Równolegle, są one przekształcane na węzły, z których powstaje drzewo DOM.
                </li>
                <li>
                  Podczas parsowania musimy uważać na skrypty, ponieważ mogą zmodyfikować one istniejący strumień wejściowy (document.write - nigdy, nigdy tego nie róbcie - przeszkadzamy w ten sposób przeglądarce).
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Skrypty</h1>
            <img src="img/async-defer-regular.png" alt="Difference between async, defer and regular" />

            <aside class="notes">
              <ul>
                <li>
                  Jeśli parser napotka definicję klasycznego skryptu (odwołującego się do zasobu sieciowego lub inline), przerywa proces parsowania i wykonuje skrypt.
                </li>
                <li>
                  Przy klasycznym podejściu zalecano aby wszystkie skrypty, które do działania potrzebują pełną wiedzę o drzewie DOM umieszczać przed zamykającym znacznikiem body.
                </li>
                <li>
                  Obecnie możemy wykorzystać do tego atrybut defer lub async, należy jednak zwrócić na różnicę między nimi.
                </li>
                <li>
                  Defer ściąga zasób w tle nie przerywając parsowania i odkłada wykonanie skryptu do momentu ściagnięcia i przetworzenia całego markupu.
                </li>
                <li>
                  Async ściąga zasób w tle i po zakończeniu tej operacji wykonuje skrypt.
                </li>
                <li>
                  W nielicznych przypadkach (takich jak np. Google Analytics) uzasadnione jest pozostawienie skryptu wewnątrz znacznika head.
                </li>
                <li>
                  Najlepszym podejściem jest pobranie tylko niezbędnych i najpopularniejszych skryptów z użyciem async/defer, natomiast resztę powinniśmy ściągnąć na żądanie, tuż przed lub w momencie wykonania operacji przez użytkownika - dzięki temu unikniemy tzw. script bomb, czyli jednego, wielkiego pliku JavaScript umieszczonego tuż przed znacznikiem zamykającym.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Reflow / Layout</h2>
            <h3>... czyli las w przeglądarce ;)</h3>

            <img src="img/detailed-process-for-layout.png" alt="Visualization of layout in the browser" />

            <aside class="notes">
              <ul>
                <li>
                  Layout to proces przetwarzania drzewa DOM w struktury przechowujące dane na temat faktycznego ułożenia na stronie, jednak nie zawierające jeszcze informacji na temat w jaki sposób należy je rysować.
                </li>
                <li>
                  Widzimy na diagramie, że tzw. drzewo renderowania składa się w wielu niezależnych drzew przechowujących różnorakie informacje. Zostało ono stworzone po wczytaniu strony i przekształceniach wykonanych za pomocą CSS oraz JavaScript.
                </li>
                <li>
                  Modyfikacja niektórych właściwości drzewa DOM z poziomu skryptów uruchamia ten proces ponownie, wraz z następstwami.
                </li>
                <li>
                  Reflow to terminologia Mozilli, Layout - to termin używany w WebKit / Blink.
                </li>
              </ul>
            </aside>
          </section>

          <section class="section-header">
            <h1>Rysowanie</h1>

            <aside class="notes">
              <ul>
                <li>Teraz dowiemy się jak przeglądarka układa piksele na ekranie.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Repaint</h2>
            <h3>... czyli przenosimy las na ekran ;)</h3>

            <img src="img/detailed-process-for-repaint.png" alt="Visualization of forest in the browser" />

            <aside class="notes">
              <ul>
                <li>Na niebiesko został oznaczony fragment, który odpowiada za repaint.</li>
                <li>
                  Jest to proces odpowiadający za przeniesienie stworzonego layoutu do bitmap, pamięci GPU i rysowanie, jak również późniejsze odrysowanie fragmentów, które uległy zmianie.
                </li>
                <li>
                  Modyfikacja niektórych właściwości drzewa DOM z poziomu skryptów uruchamia ten proces ponownie.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <div class="simulate-header">requestAnimationFrame()</div>

            <img src="img/request-animation-frame.png" alt="requestAnimationFrame importance visualization TODO" />

            <aside class="notes">
              <ul>
                <li>
                  W celu zachowania jak największej płynności przy rysowaniu, musimy się upewnić, że jesteśmy zsynchronizowani z VSYNC (vertical sync).
                </li>
                <li>
                  Jeśli Nasz budżet czasowy dla jednej ramki nie zostanie przekroczony (16.67 ms), wykorzystanie tej funkcji zagwarantuje nam, że rysowania nowej klatki rozpocznie się natychmiast po synchronizacji pionowej.
                </li>
                <li>
                  Jeśli użyjemy setTimeout/setInterval nie mamy takiej gwarancji, ponieważ nie są one powiązane z VSYNC. Jeśli wykorzystamy jedną z nich do rysowania kolejnych klatek, z bardzo dużym prawdopodobieństwem (zwiększającym się wraz ze wzrostem czasu wykonania) zaczniemy "gubić" klatki, co poskutkuje nieprzyjemnym efektem nienaturalnej animacji czy tzw. "darcia" animacji.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>A co z GPU?</h1>
            <img src="img/composition.png" alt="Composition sample" />
            <div class="fragment">Możemy wymuszać akcelerację sprzętową dla poszczególnych elementów</div>

            <aside class="notes">
              <ul>
                <li>Obecne komputery czy urządzenia mobilne posiadają bardzo wydajne GPU.</li>
                <li>
                  Kluczem do tego jest tzw. backing store i kompozycja warstw.
                </li>
                <li>
                  Przeglądarki potrafią korzystać samodzielnie z nich, jednak przy odpowiednich wskazówkach od strony twórcy aplikacji, możemy jeszcze więcej "wycisnąć" z GPU. Przykładem może być optymalizacja: CSS3 animations, CSS3 transforms, video itp. za pomocą GPU, którą praktycznie każde współczesne przeglądarki posiadają.
                </li>
                <li>
                  Najpierw element jest renderowany do tzw. bufora (który widzimy jako jedną z warstw na obrazku), następnie wysyłany do GPU i na nim odbywają się np. przekształcenia i transformacje.
                </li>
                <li>
                  Możemy dawać również wskazówki przeglądarce, wymuszając aby poszczególne elementy zostały wysłane do GPU.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h2>Wszystko na <em>GPU </em>!</h2>
            <img src="img/composite-all-the-things.jpg" alt="Composite all the things meme ;)" />

            <aside class="notes">
              <ul>
                <li>To co, wrzucamy wszystko na GPU ? ;)</li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h2>Na pewno nie wszystko</h2>
            <ul>
              <li class="fragment">Pamięć na GPU jest skończona</li>
              <li class="fragment">Koszt przesyłu danych pomiędzy RAM a VRAM</li>
              <li class="fragment">Kluczem jest tutaj znajomość aplikacji</li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  Brak pamięci jest szczególnie dotkliwy na urządzeniach mobilnych, gdzie w przypadku wypełnienia pamięci VRAM w najlepszym przypadku aplikacja bardzo mocno się spowolni (przesyłanie stron z RAM do VRAM), w najgorszym wysypie całą przeglądarkę.
                </li>
                <li>
                  Nawet na współczesnych komputerach kosztu przesyłu danych szyną pomiędzy RAM a Video RAM jest duży. Jeśli spróbujemy przepychać gigabajty danych (np. wprowadzając warstwy na wszystkie obrazki, animowane elementy etc.).
                </li>
                <li>
                  To my jako twórcy aplikacji wiemy gdzie ona tak naprawdę posiada najcieższe elementy, i możemy w ten sposób
                  wskazać przeglądarce co powinna zoptymalizować, przerzucając rysowanie tej warstwy właśnie na GPU. Bardzo często elementy takie jak CSS3 animations/transforms czy np. tag video już są akcelerowane sprzętowo.
                </li>
              </ul>
            </aside>
          </section>

          <section class="section-header">
            <h2>Ale to jeszcze nie koniec...</h2>

            <aside class="notes">
              <ul>
                <li>Zręcznie przemilczeliśmy kilka aspektów ;).</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Bateria</h1>
            <img src="img/battery-died.png" alt="Battery exhausted image" />
            <ul>
              <li class="fragment">Nadmierne wykorzystanie WiFi / 3G / 4G</li>
              <li class="fragment">Nadmierne wykorzystanie CPU i GPU</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>
                  Wydajność to nie tylko szybkość, to również efektywność - w przypadku "mobile" duże znaczenie ma właśnie czas pracy na baterii, na który również jako twórcy aplikacji webowych możemy mieć wpływ.
                </li>
                <li>
                  Dla urządzeń mobilnych radio - czyli WiFi i modemy 3G / 4G - są drugim, po wyświetlaczu, elementem najbardziej zużywającym energię. Mocne wykorzystanie i "wybudzanie" z trybu uśpienia modemu dosłownie "pożerają energię". Strony powinny więc minimalizować ilość żądań, optymalizacja dla urządzeń mobilnych bardzo często polega na przesyłaniu jak największej ilości danych przy pierwszej odpowiedzi od serwera.
                </li>
                <li>
                  Ciągłe odświeżanie strony, przerysowywanie, operacje mocno obciążające CPU również negatywnie wpływają na czas pracy na baterii. Jeśli chcemy zmaksymalizować ten czas, powinniśmy zdecydowanie unikać tego typu operacji.
                </li>
              </ul>
            </aside>
          </section>

          <section class="warning">
            <h2>Garbage Collector</h2>
            <ul class="list-style-none">
              <li>Scavenge</li>
              <li>Mark-Sweep</li>
            </ul>

            <div id="scavenge"></div>
            <div id="mark-sweep"></div>

            <aside class="notes">
              <ul>
                <li>Temat jest tak obszerny, że można stworzyć drugie szkolenie skupione tylko na tym.</li>
                <li>Główny problem z GC jest taki, że pauzy ucinają nam czas z naszego "budżetu" na daną ramkę.</li>
                <li>
                  Większość GC w przeglądarkach zaimplementowana jest w podobny sposób, więc aby dobrze opisać problem posłużymy się terminologią rodem z V8 (Google Chrome).
                </li>
                <li>
                  GC grupuje zaalokowane elementy w tzw. generacje, biorąc pod uwagę jak dawno zostały zaalokowane i jak często się do nich odwołuje.
                </li>
                <li>
                  Pierwszy typ - "scavenge" służy do usuwania młodej generacji, która już nie jest wykorzystana. Ten typ jest bardzo szybki, lub nawet bardzo często implementowany jako działający w tle, więc nie ucina czasu przeznaczonego na Naszą aktualną ramkę.
                </li>
                <li>
                  Drugi typ to bardzo kosztowna operacja, ponieważ ona zatrzymuje wykonanie w bliżej nieokreślony momencie, na który nie mamy żadnego wpływu. Czas przerwy jest zależny od rozmiaru sterty i stopnia skomplikowania grafu powiązań.
                </li>
                <li>
                  Jeśli mamy budżet ramki 16.67 ms a faza 'mark-sweep' trwa 60 ms mamy spory problem.
                </li>
                <li>
                  Jedyny wpływ jaki mamy na GC to zmiana sposobu tworzenia/'usuwania' nowych elementów w skryptach.
                </li>
              </ul>
            </aside>

            <script>
              (function() {
                var scavengePaper = Raphael("scavenge", 640, 480),
                    markSweepPaper = Raphael("mark-sweep", 640, 480),

                    scavenge = scavengePaper.gearBox(),
                    markSweep = markSweepPaper.gearBox(),

                    scavengeCounter = 0,
                    markSweepCounter = 0;

                setInterval(function() {
                  scavenge.animate({ transform: "r" + scavengeCounter }, 500);
                  scavengeCounter += 50;
                }, 501);

                setInterval(function() {
                  markSweep.animate({ transform: "r" + markSweepCounter }, 1000);
                  markSweepCounter += 15;
                }, 1001);
              } ());
            </script>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Narzędzia</h1>
          </section>

          <section>
            <h1>Developer Tools</h1>
            <aside class="notes">
              <ul>
                <li>
                  Wszystkie zaprezentowane funkcjonalności są dostępne w wersjach deweloperskich przeglądarek (Chrome Canary, Firefox Nightly).
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Timeline</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Prezentacja timeline, filtrowanie, ostrzeżenia, wyłaśnienie wyglądu.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Profilowanie</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Flamecharts, CPU</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Pamięć</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Spanshots, differences, comparison etc.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Network</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Wyjaśnienie, przydatne tricki, kolory kresek.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Konsola</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Wywoływanie profilera, formatowanie, tabelki, snapshoty, skróty.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Chrome - Renderowanie</h1>
            <aside class="notes">
              <ul>
                <li>TODO: FPS, Continuous repaint mode, Layers etc.
              </ul>
            </aside>
          </section>

          <section>
            <h1>Firefox</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Skupić się na profilowaniu.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>IE 9 / 10</h1>

            <img src="img/ie-10.png" alt="IE 10 presentation" />

            <aside class="notes">
              <ul>
                <li>
                  Z interesujących nas rzeczy IE w wersji 9 i 10 udostępniają nam tylko zakładki do badania sieci i profilowania.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>IE 11</h1>

            <img src="img/ie-11.gif" alt="IE 11 presentation" />

            <aside class="notes">
              <ul>
                <li>Wreszcie narzędzia deweloperskie dogoniły to co dostarczone zostało już dawno w Google Chrome.</li>
                <li>
                  Zakładka symulująca timeline taki jak w Google Chrome, została stworzona po naciskach społeczności na Microsoft, które miały miejsce również na polskiej konferencji Front-Trends 2013 (akcja na Twitterze).
                </li>
                <li>Prezentacja z wersji IE dołączonej do Windows 8.1.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>Inne</h1>
            <p>
              Najważniejsze to dobrze poznać narzędzia deweloperskie z ulubionej przeglądarki
            </p>

            <aside class="notes">
              <ul>
                <li>
                  Obecnie narzędzia deweloperskie w Safari i Operze nie różnią się znacznie od zaprezentowanych narzędzi z Google Chrome (to przecież nadal silniki Webkit i Blink).
                </li>
                <li>
                  Jedna z wersji Safari posiada narzędzie do pokazywania warstw i kompozycji umieszczonych w pamięci GPU. Nie wiadomo dlaczego funkcjonalność została wycofana w następnej wersji.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Navigation Timing API</h2>

            <img src="img/timing-api-overview.png" alt="Navigation Timing API" />

            <aside class="notes">
              <ul>
                <li>
                  Bardzo pożyteczne API, umożliwiające zebranie statystyk po stronie klienta w celu określenia parametrów jego połączenia.
                </li>
                <li>
                  Trzy kolory na obrazku reprezentują podział na część sieciową (niebieski), czas spędzony na serwerze (czerwony), oraz po stronie przeglądarki (zielony). Pomarańczowym kolorem wyróżniono w którym momencie wywoływane są zdarzenia związane z ładowaniem strony.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Navigation Timing API</h2>

            <img src="img/timing-api-usage.gif" alt="Navigation Timing API usage" />

            <aside class="notes">
              <ul>
                <li>Widzimy na slajdzie przykład zastosowania omawianego API.</li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>ySlow</h1>

            <img src="img/yslow.gif" alt="ySlow presentation TODO" />

            <aside class="notes">
              <ul>
                <li>
                  ySlow to narzędzie od Yahoo, służące do audytowania stron pod kątem specjalnie przygotowanej klasyfikacji.
                </li>
                <li>
                  Pomocne, szczególnie jeśli chcemy wykonać inny audyt porównawczy.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>PageSpeed</h2>

            <img src="img/pagespeed.png" alt="Audit made from PageSpeed online" />

            <aside class="notes">
              <ul>
                <li>
                  Kolejne narzędzie służące do audytowania według określonych reguł, tym razem od Google. Dostępne w wersji online i jako rozszerzenie do Google Chrome / Chromium.
                </li>
                <li>
                  Wersja webowa jest rozszerzona o np. wyszukiwanie ścieżki krytycznej lub testy pod kątem urządzeń mobilnych, ale wymaga aby aplikacja była dostępna w internecie.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Google Speed Tracer</h2>
            <h2>Chrome Web Performance Toolkit</h2>

            <img src="img/google-speed-tracer.png" alt="Google Speed Tracer presentation" />

            <aside class="notes">
              <ul>
                <li>
                  Kolejne narzędzia dostępne w postaci rozszerzenia do przeglądarki, zbierające dane dot. sieci oraz wykonania skryptów, renderowania etc.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Chrome Hidden Pages</h2>
            <ul>
              <li><a href="chrome://version/">chrome://version/</a></li>
              <li><a href="chrome://tracing">chrome://tracing</a></li>
              <li><a href="chrome://histograms/DNS.ResolveSuccess">chrome://histograms/DNS.ResolveSuccess</a></li>
              <li>... i wiele, wiele innych</li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  Polecam zapoznać się ze stronami które Chrome domyślnie posiada, przykładowe trzy wymienione przeze mnie dostarczają ciekawych informacji.
                </li>
                <li>
                  Warto również odwiedzić stronę chrome://flags i poeksperymentować z ustawieniami, być może znajdziemy nową ciekawą funkcjonalność.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h3>Windows Performance Toolkit</h3>

            <img src="img/wpt-presentation.png" alt="Windows Performance Toolkit presentation TODO" />

            <aside class="notes">
              <ul>
                <li>Potężne narzędzie, zbierające dane na bardzo niskim poziomie, również z IE 11.</li>
                <li>Dostępne na TODO.</li>
                <li>
                  Daje jeszcze większy przegląd sytuacji, zwłaszcza jeśli chodzi o szczegółowe informacje pochodzące z IE 11 (z dokładnością do wywołań funkcji systemowych i np. sterowników karty graficznej etc.).
                </li>
                <li>
                  Zaprezentuje dzisiaj możliwości tego narzędzia przy optymalizacji.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h1>V8 profiler - D8</h1>
            <aside class="notes">
              <ul>
                <li>TODO: Krótko, bez rozwodzenia się + prezentacja w gif.</li>
              </ul>
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Benchmarki</h1>

            <aside class="notes">
              Chciałbym zająć się teraz trudną sztuką tworzenia benchmarków. Jest to zagadnienie tak obszerne, że naprawdę można mu poświęcić całą nową prezentację, natomiast ja chciałbym pokazać jak uniknąć najpopularniejszych pułapek przy tworzeniu benchmarków typowo JavaScriptowych i problemów związanych z tą tematyką.
            </aside>
          </section>

          <section class="good">
            <h1>Tryb prywatny</h1>
            <aside class="notes">
              <ul>
                 <li>
                   Zanim przejdziemy do narzędzi. Chciałbym podkreślić najważniejszą rzecz. Najważniejsza jest odpowiednia izolacja takiego benchmarku i w ogóle testów wydajnościowych - najlepiej jest to robić w tzw. trybie prywatnym (incognito).
                 </li>
                 <li>
                   Nie musimy pamiętać o wszystkich elementach które mogą wpływać na nasze testy tj. o pluginach, cache, historii, ustawieniach profilu, ciasteczkach etc.
                 </li>
               </ul>
            </aside>
          </section>

          <section>
            <h1>Narzędzia</h1>
            <ul>
              <li class="fragment"><a href="http://jsperf.com/">jsperf</a></li>
              <li class="fragment"><a href="http://www.browserscope.org/">Browserscope</a></li>
              <li class="fragment">d8, node --profiler</li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  Przejdźmy do narzędzi - najpopularniejszym jest ten przeklęty jsperf. Przeklęty ponieważ jest bardzo łatwy w (nad)użyciu. Prostota stworzenia testu i łatwość współdzielenia wyników przysłania bardzo często zdrowy rozsądek.
                </li>
                <li>
                  O nadużywaniu jsperf opowiemy sobie dokładnie za chwilę.
                </li>
                <li>
                  Inną kategorią narzędzi są strony porównawcze - Browserscope jest najpopularniejszą i najobszerniejszą bazą wiedzy nt. przeglądarek, również związaną z wydajnością.
                </li>
                <li>
                  Ostatnia kategoria to ciężka artyleria, którą krótko zaprezentowałem wcześniej - czyli tak naprawdę niskopoziomowe profilery dla V8/Node, które umożliwiają dosłownie na spojrzenie pod maskę silnika JavaScript i wykrycia potencjalnych błędów.
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h2>Microbenchmarks</h2>
            <img src="img/microbenchmark.png" alt="Microbenchmark sample" />
            <aside class="notes">
              <ul>
                <li>
                  Powiedzieliśmy sobie, że bardzo łatwo nadużyć jsperf. Prowadzi to do zjawiska zwanego Microbenchmarkingiem, czyli skupienie na bardzo małych fragmentach kodu i wyciśnięciu z nich siódmych potów.
                </li>
                <li>
                  Problem polega na tym, że środowisko przeglądarkowe nie jest dobrym miejscem do skupiania się na tego typu optymalizacjach, ponieważ mamy zbyt mały wpływ na nie.
                </li>
                <li>
                  W przykładzie widzimy prostą funkcję z 4 parametrami i będziemy testować narzut dla określonego sposobu jej wywołania (6 przypadków testowych).
                </li>
              </ul>
            </aside>
          </section>

          <section class="bad">
            <h2>You do it wrong!</h2>
            <img src="img/microbenchmark-results.png" alt="Microbenchmark sample" />
            <aside class="notes">
              <ul>
                <li>
                  Przez to, że nie mamy praktycznie żadnego wpływu na JIT zostaliśmy oszukani i co gorsza wyciągamy błędne wnioski pt. "W Chrome 32 znacznie przyspieszyli klasyczny sposób wywoływania funkcji".
                </li>
              </ul>
            </aside>
          </section>

          <section data-transition="none">
            <h2>Dlaczego?</h2>
            <pre><code data-trim class="javascript">
function benchmark() {
  function fn(a, b, c, d) {
    return a + b + c + d;
  }

  var start = new Date;
  for (var n = 0; n < 1e6; n++) {
    fn('a', 'b', 'c', 'd');
  }
  return (new Date - start);
}
            </code></pre>
          </section>

          <section data-transition="none">
            <h2>Dlaczego?</h2>
            <pre><code data-trim class="javascript">
function benchmark() {
  var start = new Date;
  for (var n = 0; n < 1e6; n++) {
    // Ponieważ znamy fn, rozwijamy ją w miejscu wywołania:
    a + b + c + d;
  }
  return (new Date - start);
}
            </code></pre>
          </section>

          <section data-transition="none">
            <h2>Dlaczego?</h2>
            <pre><code data-trim class="javascript">
function benchmark() {
  var start = new Date;
  for (var n = 0; n < 1e6; n++) {
    // Wynik nie jest nigdzie używany więc kompilator go usunie...
  }
  return (new Date - start);
}
            </code></pre>
          </section>

          <section data-transition="none">
            <h2>Dlaczego?</h2>
            <pre><code data-trim class="javascript">
function benchmark() {
  var start = new Date;

  // ... razem z pętlą for, która była teraz pusta ;).

  return (new Date - start);
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>
                  Ważniejsze jednak od tego jak to naprawić, jest zupełnie co innego. Powinniśmy skupiać się raczej na profilowaniu całości i optymalizacji całego rozwiązania, niż wyszukiwać najoptymalniejsze drobiazgi implementacyjne (za dużo przeglądarek, zbyt mały wpływ na środowisko, od tego jest JIT).
                </li>
              </ul>
            </aside>
          </section>

          <section class="good">
            <h2>Don't take performance advices from strangers!</h2>
            <h4><a href="https://github.com/felixge/faster-than-c">Felix Geisendörfer</a></h4>
            <aside class="notes">
              Na koniec dwie bardzo ważne rady - nie przyjmujmy rad dot. wydajności od obcych na ślepo. Nie szukajmy w internecie, na blogach, na forach odpowiedzi na Nasze pytania - to My znamy system i to My powinniśmy go zbadać.
            </aside>
          </section>

          <section class="good">
            <h2>Don't guess it, test it!</h2>
            <h4><a href="http://www.aerotwist.com/blog/dont-guess-it-test-it/">Paul Lewis</a></h4>
            <aside class="notes">
              Nic dodać nic ująć - Najpierw zbadać, potem optymalizować - najpierw zmierzyć potem uciąć. Nie powinniśmy strzelać na oślep technikami optymalizacyjnymi (zasada Pareto 80/20 ma wszędzie zastosowanie) mimo, że z dużym prawdopodobieństwem trafimy to zmarnujemy czas i zasoby.
            </aside>
          </section>

        </section>

        <section>

          <section class="section-header">
            <h1>Case Studies</h1>
          </section>

          <section>
            <h2>JavaScript</h2>
          </section>

          <section>
            <h1>Pamięć</h1>
          </section>

          <section>
            <h1>DOM</h1>
          </section>

          <section>
            <h1>Sieć</h1>
          </section>

        </section>

        <section class="section-header">
          <h1>Pytania?</h1>
        </section>

        <section class="section-header">
          <h2>Dziękuję za uwagę!</h2>
          <h4>Odniesienia i bibliografia:</h4>
          <ul class="links">
            <li>
              <a href="https://docs.google.com/presentation/d/1ZRIQbUKw9Tf077odCh66OrrwRIVNLvI_nhLm2Gi__F0/pub#slide=id.p">
                How WebKit works
              </a>
            </li>
            <li>
              <a href="http://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html">
                Microbenchmarks fairy tale
              </a>
            </li>
            <li>
              <a href="http://www.youtube.com/watch?v=65-RbBwZQdU">
                Performance and benchmarking
              </a>
            </li>
            <li>
              <a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-04">HTTP 2.0</a>
              oraz
              <a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">SPDY</a>
            </li>
            <li>
              <a href="https://github.com/marcelduran/yslow">YSlow</a>
            </li>
            <li>
              <a href="http://w3c-test.org/webperf/specs/NavigationTiming/">Navigation Timing API</a>
            </li>
            <li>
              <a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code/">Visualizations of LOC</a>
            </li>
            <li>
              <a href="http://discover-devtools.codeschool.com/">CodeSchool - Google Chrome Developer Tools</a>
            </li>
            <li>
              <a href="http://devtoolsecrets.com/">Developer Tools Tips and Tricks</a>
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      var BLUE = "#63ABF0",
          RED = "#FA5F0C",
          GREEN = "#52A617",
          YELLOW = "#FFC03C";

      Function.prototype.curry = function() {
        var fn = this,
            args = [].slice.call(arguments);

        return function() {
          return fn.apply(this, args.concat([].slice.call(arguments)));
        };
      };

      function getArrayOfDomElements(selector) {
        return [].slice.call(document.querySelectorAll(selector));
      }

      function applyColor(color, element) {
        element.setAttribute("data-background", color);
      }

      getArrayOfDomElements(".section-header").forEach(applyColor.curry(BLUE));
      getArrayOfDomElements(".good").forEach(applyColor.curry(GREEN));
      getArrayOfDomElements(".bad").forEach(applyColor.curry(RED));
      getArrayOfDomElements(".warning").forEach(applyColor.curry(YELLOW));

      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: "default",
        transition: "slide",
        transitionSpeed: "fast",
        backgroundTransition: "linear",

        dependencies: [
          {
            src: "lib/js/classList.js",condition: function() { return !document.body.classList; }
          },
          {
            src: "plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); }
          },
          {
            src: "plugin/zoom-js/zoom.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "plugin/notes/notes.js", async: true, condition: function() { return !!document.body.classList; }
          },
          {
            src: "socket.io/socket.io.js", async: true
          },
          {
            src: "plugin/notes-server/client.js", async: true
          }
        ]
      });
    </script>
  </body>
</html>